#+TITLE: The LENS package
#+AUTHOR: Dr. John A.R. Williams
#+EMAIL: J.A.R.Williams@aston.ac.uk
#+LINK: hs http://www.lispworks.com/reference/HyperSpec//%s
#+STYLE: <link rel="stylesheet" type="text/css" href="clod.css" />
#+STARTUP: showall
#+OPTIONS: toc:4 H:10 @:t tags:nil

# link target 2: <<lens>>
# link target: <<package lens>>


* Internal Package: =lens=                                               :package:

- Uses:
    [[package closer-common-lisp][closer-common-lisp]], [[package closer-common
    lisp-user][closer-common-lisp-user]], [[package data-format-validation][data
    format-validation]]
- Used by:
    None.

** Description

This package provides the main simulation
  framework. It is intended that every simulation system will be
  defined in its own package which will use this package to import the
  public API. Simulations should be run from within the dynamic
  context of their specific simulation package so that symbolic
  configuration parameters will be read into the correct package.

Simulations are represented as a heirarchical network of
modules interconnected using channels. Every simulation must have one
top level network module which will specify submodules and their
interconnections. These submodules may be compound modules which can
contain further submodules or simple modules which contain
implementations. All module types are declared as CLOS classes
inheriting from [[network]], [[compound-module]] and
[[module]] base classes as appropriate. In addition module classes
must declare a metaclass - [[compound-module-class]] for
networks and compound modules and [[module-class]] for simple
modules. These meta-classes allow for the declaration of parameter
slots (where the value may be initialised from the configuration
file), gates, submodules and connections in the class definition.
When a simulation is run the network type is read from the parameter
file and created. This will then create the submodules and so on until
the whole network is created.


** External Symbols




*** External Classes

-----

# link target: <<class channel>>


**** External Class: =channel=                                                :class:


***** Inheritance

- Parent classes:
    [[class component][component]]
- Precedence list:
    [[class channel][channel]], [[class component][component]], [[class parameter
    object][parameter-object]], [[class entity-with-signals][entity-with-signals]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class delay-channel][delay-channel]], [[class transmission
    channel][transmission-channel]], [[class ideal-channel][ideal-channel]]


***** Parameters



***** Description

Base class for all channels entities in the
  simulations. Channells are attached to their source gate.


***** Direct Slots

# link target 2: <<source-gate>>
# link target: <<slot source-gate>>


****** Internal Slot: =source-gate=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: source-gate
- Allocation: instance


******* Description

The gate which sends messages over the channel.


******* Accessors

-----

# link target 2: <<source-gate>>
# link target: <<slot-accessor source-gate>>


******** Internal Slot Accessor: =source-gate=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(source-gate object)
#+END_SRC


********* Methods

- (=source-gate= (channel [[class channel][=channel=]]))







***** Indirect Slots

# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<component>>
# link target: <<class component>>


**** External Class: =component=                                              :class:


***** Inheritance

- Parent classes:
    [[class parameter-object][parameter-object]], [[class entity-with
    signals][entity-with-signals]]
- Precedence list:
    [[class component][component]], [[class parameter-object][parameter-object]],
    [[class entity-with-signals][entity-with-signals]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    [[class module][module]], [[class channel][channel]]


***** Parameters

- collect-trace-info :: a =boolean=.  If true tracelog outputs will be traced for this component.
***** Description

[[class component]] adds in random
number sequence mapping and tracing functionality on top of parameter
and signal handling. It is the base class for all modules and channels
in simulation which require these.

****** Additional Parameters


- rng-<n> :: a =integer=. Specifies the global random number sequence number
  to be mapped to the =n= th sequence for this component
- scalar-recording :: a =boolean=. If true scalar recording will be activated
   for statistics objects associated with this component.
- vector-recording :: a =boolean=. If true vector recording will
    be activated for statistics objects associated with this component.

***** Notes


Both tracing (using tracelog) and rng mapping depend on
the =*context*= dynamic global variable being set to the correct component.
This is set for initialize-instance, finish and for handle-message.
Functions or methods designed to be used to access a component
directly outside these contexts /must/ explicitely bind =*context*= around
around any dynamic context using random number generation or tracing.
and /should/ do it in all such cases as a matter of safe practice.

***** Direct Slots

# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


******* Accessors

-----

# link target 2: <<rng-map>>
# link target: <<slot-accessor rng-map>>


******** External Slot Accessor: =rng-map=                                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(rng-map context)
#+END_SRC


********* Methods

- (=rng-map= (component [[class component][=component=]]))
- (=rng-map= (simulation [[class simulation][=simulation=]]))
- (=rng-map= (context (eql nil)))





# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


******* Accessors

-----

# link target 2: <<initialized-p>>
# link target: <<slot-accessor initialized-p>>


******** External Slot Accessor: =initialized-p=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(initialized-p component)
#+END_SRC

********* Arguments


- component ::  a simulation [[component]]

********* Description


Returns true if an entity has finished its initialization using the
[[initialize]] method.

********* Methods

- (=initialized-p= (component [[class component][=component=]]))
- (=initialized-p= (simulation [[class simulation][=simulation=]]))







***** Indirect Slots

# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<compound-module>>
# link target: <<class compound-module>>


**** External Class: =compound-module=                                        :class:


***** Inheritance

- Parent classes:
    [[class module][module]]
- Precedence list:
    [[class compound-module][compound-module]], [[class module][module]], [[class
    component][component]], [[class parameter-object][parameter-object]], [[class
    entity-with-signals][entity-with-signals]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    [[class network][network]]


***** Parameters



***** Description

Base class for all compound-modules using the [[compound-module-class]] metaclass. See [[class compound-module-class]] for details of the additional class slot options available.

Typically no further implementation beyond the class specification is
used with compound modules as messages will be automatically routed in
the gates of submodules as per the =:connections= specifications. It
is however allowed to have unconnected gates in which case
[[handle-message]] must be implemented to receive the messages. This
would allow some implementation in compound modules which they might
then send to several contained submodules.

The [[build-submodules]] and [[build-connections]] may be usefully
extended to allow algorithmic creation of the contained network.


***** Direct Slots

# link target 2: <<submodules>>
# link target: <<slot submodules>>


****** Internal Slot: =submodules=                                               :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<submodules>>
# link target: <<slot-accessor submodules>>


******** Internal Slot Accessor: =submodules=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(submodules object)
#+END_SRC


********* Methods

- (=submodules= (compound-module [[class compound-module][=compound-module=]]))





# link target 2: <<channels>>
# link target: <<slot channels>>


****** Internal Slot: =channels=                                                 :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<channels>>
# link target: <<slot-accessor channels>>


******** Internal Slot Accessor: =channels=                               :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(channels object)
#+END_SRC


********* Methods

- (=channels= (compound-module [[class compound-module][=compound-module=]]))







***** Indirect Slots

# link target 2: <<gate-slots>>
# link target: <<slot gate-slots>>


****** Internal Slot: =gate-slots=                                               :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash table mapping gate names to [[gate-slot]]
    instances as specified in the =:gates= slot option in the class
    specification of subclasses.


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<compound-module-class>>
# link target: <<class compound-module-class>>


**** External Class: =compound-module-class=                                  :class:


***** Inheritance

- Parent classes:
    [[class module-class][module-class]]
- Precedence list:
    [[class compound-module-class][compound-module-class]], [[class module
    class][module-class]], [[class parameter-class][parameter-class]], [[class
    standard-class][standard-class]], [[class std-class][std-class]], [[class slot
    class][slot-class]], [[class pcl-class][pcl-class]], [[class class][class]],
    [[class dependent-update-mixin][dependent-update-mixin]], [[class plist
    mixin][plist-mixin]], [[class definition-source-mixin][definition-source
    mixin]], [[class standard-specializer][standard-specializer]], [[class
    specializer][specializer]], [[class metaobject][metaobject]], [[class standard
    object][standard-object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.

***** Additional Class Options


- types :: ( (/typename/ /initargs/)* )

           * /typename/ : a =symbol=

           * /initargs/ : (classname {keyword argument}*)

- submodules :: ( (/submodule-name/ [/sizespec/] ((/classname/ | /typename/) {/keyword/ /argument/}* ) *)

           * /submodule-name/ : a =symbol=

           * /sizespec/ : (integer | (sizeof gate-name) | slot-name)

- connections :: ( /(gate-specifier/ [/channel-spec/] /direction/ /gate-specifier/)* )

            * /gate-specifier/ : (/gate-name/ | (/submodule-name/ /gate-name/))

            * /channel-spec/ : ((/classname/ | /typename/) {/keyword/ /argument/}* )

            * /direction/ : (=> | <=> | <=)

***** Description


Metaclass for all compound modules classes - the base class for
modules with gates, submodules and connections between those
submodules and gates. Must be used as metaclass for
[[compound-module]] classes.

See [[module-class]] for details on the =:gates=  class option.

The =:types= class option provides a way of providing a mapping
between a single symbolic /typename/ and a list of /initargs/ which
would correspond to the /classname/ and keyword arguments passed in
construction of either a submodule or channel. These names thus
provide a useful shortcut when defining submodules or channels. If a
/typename/ is specified with some additional arguments they will
override the default ones.

The =:submodules= class option provides a list of submodule class
specifications consisting of the local name for the submodule, an
optional /sizespec/ if an array of submodules is to be created and the
arguments to =make-instance= to be used. A previously defined local
type shortcut may be used instead of the classname. At creation the
=:owner= keywword will be added to the /initargs/ with the current
instance as the argument. A /sizespec/ may either be an integer, a
symbolic slot-name corresponding to one of the slots in the class or
=(sizeof gate-name)= which will correspond to the size of the array of
gates with the given gate-name.

The =:connections= class option specifies connections between
gates.  Gates are specified either as the gate name if a gate in the
current module or a list of submodule name and gate name for
submodules. They may additionally have an index parameter if
corresponding to gate arrays. The direction specifier specifies the
direction of connection, =<=>= may be used to provide connections in
both directions between =:inout= gates. An optional channel specifier
may be used as the second argument specifying the channel type and
initargs for creating the channel. The type may be a local type
definied with the =:types= slot option. The =:name= argument may be
used to give individual channels names - otherwise they will be named
after their type name. The =:owner= keyword argument will be added
with the current object instance as the argument.

***** Direct Slots

# link target 2: <<..25..localtypes>>
# link target: <<slot ..25..localtypes>>


****** Internal Slot: =%localtypes=                                              :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: types
- Allocation: instance


******* Description

Specified local type mapping.


# link target 2: <<..25..submodules>>
# link target: <<slot ..25..submodules>>


****** Internal Slot: =%submodules=                                              :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: submodules
- Allocation: instance


******* Description

Submodule specifications


# link target 2: <<..25..connections>>
# link target: <<slot ..25..connections>>


****** Internal Slot: =%connections=                                             :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: connections
- Allocation: instance


******* Description

Connection specification for this class




***** Indirect Slots

# link target 2: <<..25..gatespec>>
# link target: <<slot ..25..gatespec>>


****** Internal Slot: =%gatespec=                                                :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The parsed gate specification used to build gates for this class


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The properties for this class


# link target 2: <<slots>>
# link target: <<slot slots>>


****** Internal Slot: =slots=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-slots>>
# link target: <<slot direct-slots>>


****** Slot: =direct-slots=                                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<prototype>>
# link target: <<slot prototype>>


****** Slot: =prototype=                                                         :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<wrapper>>
# link target: <<slot wrapper>>


****** Slot: =wrapper=                                                           :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<incompatible-superclass-list>>
# link target: <<slot incompatible-superclass-list>>


****** Slot: =incompatible-superclass-list=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<can-precede-list>>
# link target: <<slot can-precede-list>>


****** Slot: =can-precede-list=                                                  :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<cpl-available-p>>
# link target: <<slot cpl-available-p>>


****** Slot: =cpl-available-p=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<..25..class-precedence-list>>
# link target: <<slot ..25..class-precedence-list>>


****** Slot: =%class-precedence-list=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<finalized-p>>
# link target: <<slot finalized-p>>


****** Slot: =finalized-p=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<safe-p>>
# link target: <<slot safe-p>>


****** Slot: =safe-p=                                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: safe-p
- Allocation: instance


******* Description



# link target 2: <<..25..documentation>>
# link target: <<slot ..25..documentation>>


****** Slot: =%documentation=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: documentation
- Allocation: instance


******* Description



# link target 2: <<direct-methods>>
# link target: <<slot direct-methods>>


****** Slot: =direct-methods=                                                    :slot:

- Value type: =t=
- Initial value: =(CONS NIL NIL)=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-subclasses>>
# link target: <<slot direct-subclasses>>


****** Slot: =direct-subclasses=                                                 :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-superclasses>>
# link target: <<slot direct-superclasses>>


****** Internal Slot: =direct-superclasses=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target: <<slot class-eq-specializer>>


****** Slot: =class-eq-specializer=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description



# link target 2: <<plist>>
# link target: <<slot plist>>


****** Slot: =plist=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: plist
- Allocation: instance


******* Description



# link target 2: <<source>>
# link target: <<slot source>>


****** Internal Slot: =source=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: definition-source
- Allocation: instance


******* Description



# link target 2: <<..25..type>>
# link target: <<slot ..25..type>>


****** Slot: =%type=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description






-----

# link target 2: <<delay-channel>>
# link target: <<class delay-channel>>


**** External Class: =delay-channel=                                          :class:


***** Inheritance

- Parent classes:
    [[class channel][channel]]
- Precedence list:
    [[class delay-channel][delay-channel]], [[class channel][channel]], [[class
    component][component]], [[class parameter-object][parameter-object]], [[class
    entity-with-signals][entity-with-signals]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.


***** Parameters

- delay :: a =time-type=. Default: =0.0d0=. The propagation delay in seconds
- disabled-p :: a =bool=.  NIL

***** Description

A [[channel]] with propagation delay.


***** Direct Slots

# link target 2: <<delay>>
# link target: <<slot delay>>


****** External Slot: =delay=                                                    :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: delay
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

The propagation delay in seconds


******* Accessors

-----

# link target 2: <<delay>>
# link target: <<slot-accessor delay>>


******** External Slot Accessor: =delay=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(delay object)
#+END_SRC


********* Methods

- (=delay= (delay-channel [[class delay-channel][=delay-channel=]]))





# link target 2: <<disabled-p>>
# link target: <<slot disabled-p>>


****** External Slot: =disabled-p=                                               :slot:

- Value type: =bool=
- Initial value: =NIL=
- Initargs: disabled
- Allocation: instance
- Parameter: t
- Properties: nil


******* Accessors

-----

# link target 2: <<disabled-p>>
# link target: <<slot-accessor disabled-p>>


******** External Slot Accessor: =disabled-p=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(disabled-p object)
#+END_SRC


********* Methods

- (=disabled-p= (delay-channel [[class delay-channel][=delay-channel=]]))







***** Indirect Slots

# link target 2: <<source-gate>>
# link target: <<slot source-gate>>


****** Internal Slot: =source-gate=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: source-gate
- Allocation: instance


******* Description

The gate which sends messages over the channel.


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<entity-with-signals>>
# link target: <<class entity-with-signals>>


**** External Class: =entity-with-signals=                                    :class:


***** Inheritance

- Parent classes:
    [[class owned-object][owned-object]]
- Precedence list:
    [[class entity-with-signals][entity-with-signals]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    [[class packet-buffer][packet-buffer]], [[class component][component]]


***** Description

An entity which can [[subscribe]] to and [[emit]] and
  [[receive-signal]] signals.


***** Direct Slots

# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


******* Accessors

-----

# link target 2: <<signal-table>>
# link target: <<slot-accessor signal-table>>


******** Internal Slot Accessor: =signal-table=                           :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(signal-table object)
#+END_SRC


********* Methods

- (=signal-table= (entity-with-signals                  [[class entity-with
  signals][=entity-with-signals=]]))





# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.




***** Indirect Slots

# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target: <<class gate>>


**** External Class: =gate=                                                   :class:


***** Inheritance

- Parent classes:
    [[class owned-object][owned-object]]
- Precedence list:
    [[class gate][gate]], [[class owned-object][owned-object]], [[class named
    object][named-object]], [[class lens-object][lens-object]], [[class standard
    object][standard-object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Represents a module gate. Created and managed by
modules; the user typically does not want to directly create or
destroy gate objects. However, they are important if a module
algorithm needs to know about its surroundings. Module gates connect
only in one direction. Bidirectional connections result in two chains
of gates going in each direction.


***** Direct Slots

# link target 2: <<previous-gate>>
# link target: <<slot previous-gate>>


****** Internal Slot: =previous-gate=                                            :slot:

- Value type: =link=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The previous gate in the series of connections (the path)


******* Accessors

-----

# link target 2: <<previous-gate>>
# link target: <<slot-accessor previous-gate>>


******** Internal Slot Accessor: =previous-gate=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(previous-gate object)
#+END_SRC


********* Methods

- (=previous-gate= (gate [[class gate][=gate=]]))





# link target 2: <<next-gate>>
# link target: <<slot next-gate>>


****** Internal Slot: =next-gate=                                                :slot:

- Value type: =link=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The next gate in the series of connections (the path)


******* Accessors

-----

# link target 2: <<next-gate>>
# link target: <<slot-accessor next-gate>>


******** Internal Slot Accessor: =next-gate=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(next-gate object)
#+END_SRC


********* Methods

- (=next-gate= (gate [[class gate][=gate=]]))





# link target: <<slot channel>>


****** External Slot: =channel=                                                  :slot:

- Value type: =channel=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Channel object (if exists) to next link


******* Accessors

-----

# link target: <<slot-accessor channel>>


******** External Slot Accessor: =channel=                                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(channel object)
#+END_SRC


********* Methods

- (=channel= (gate [[class gate][=gate=]]))





# link target 2: <<deliver-on-reception-start-p>>
# link target: <<slot deliver-on-reception-start-p>>


****** External Slot: =deliver-on-reception-start-p=                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Messages with nonzero length then have a nonzero
    transmission duration (and thus, reception duration on the other
    side of the connection). By default, the delivery of the message
    to the module marks the end of the reception. Setting this bit
    will cause the channel to deliver the message to the module at the
    start of the reception. The duration that the reception will take
    can be extracted from the message object, by its duration()
    method.


******* Accessors

-----

# link target 2: <<deliver-on-reception-start-p>>
# link target: <<slot-accessor deliver-on-reception-start-p>>


******** External Slot Accessor: =deliver-on-reception-start-p=           :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(deliver-on-reception-start-p object)
#+END_SRC


********* Methods

- (=deliver-on-reception-start-p= (gate [[class gate][=gate=]]))







***** Indirect Slots

# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<gate-slot>>
# link target: <<class gate-slot>>


**** External Class: =gate-slot=                                              :class:


***** Inheritance

- Parent classes:
    [[class owned-object][owned-object]]
- Precedence list:
    [[class gate-slot][gate-slot]], [[class owned-object][owned-object]], [[class
    named-object][named-object]], [[class lens-object][lens-object]], [[class
    standard-object][standard-object]], [[class slot-object][slot-object]], [[class
    t][t]]
- Direct subclasses:
    None.


***** Description

Named storage slot for gate or gates - direction
  initarg must be specified as :input, :output or :inout. If an
  initial size is given then it will be an array of gates and access
  must by index


***** Direct Slots

# link target 2: <<input>>
# link target: <<slot input>>


****** External Slot: =input=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Slot for input gate or gates


******* Accessors

-----

# link target 2: <<input>>
# link target: <<slot-accessor input>>


******** External Slot Accessor: =input=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(input object)
#+END_SRC


********* Methods

- (=input= (gate-slot [[class gate-slot][=gate-slot=]]))



-----

# link target 2: <<input-gate-p>>
# link target: <<slot-accessor input-gate-p>>


******** Internal Slot Accessor: =input-gate-p=                           :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(input-gate-p object)
#+END_SRC


********* Methods

- (=input-gate-p= (gate-slot [[class gate-slot][=gate-slot=]]))





# link target 2: <<output>>
# link target: <<slot output>>


****** External Slot: =output=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Slot for output gate or gates


******* Accessors

-----

# link target 2: <<output>>
# link target: <<slot-accessor output>>


******** External Slot Accessor: =output=                                 :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(output object)
#+END_SRC


********* Methods

- (=output= (gate-slot [[class gate-slot][=gate-slot=]]))



-----

# link target 2: <<output-gate-p>>
# link target: <<slot-accessor output-gate-p>>


******** Internal Slot Accessor: =output-gate-p=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(output-gate-p object)
#+END_SRC


********* Methods

- (=output-gate-p= (gate-slot [[class gate-slot][=gate-slot=]]))







***** Indirect Slots

# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<histogram>>
# link target: <<class histogram>>


**** External Class: =histogram=                                              :class:


***** Inheritance

- Parent classes:
    [[class stddev][stddev]]
- Precedence list:
    [[class histogram][histogram]], [[class stddev][stddev]], [[class scalar
    recorder][scalar-recorder]], [[class result-recorder][result-recorder]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Base class for density estimation classes.

 For the histogram classes, you need to specify the number of cells
 and the range. Range can either be set explicitly or you can choose
 automatic range determination.

 Automatic range estimation works in the following way:

 1.  The first num_firstvals observations are stored.
 2.  After having collected a given number of observations, the actual
     histogram is set up. The range (*min*, *max*) of the
     initial values is expanded *range_ext_factor* times, and
     the result will become the histogram's range (*rangemin*,
     *rangemax*). Based on the range, the cells are layed out.
     Then the initial values that have been stored up to this point
     will be transferred into the new histogram structure and their
     store is deleted -- this is done by the transform() function.

You may also explicitly specify the lower or upper limit and have
the other end of the range estimated automatically. The setRange...()
member functions of cDensityEstBase deal with setting
up the histogram range. It also provides pure virtual functions
transform() etc.

Subsequent observations are placed in the histogram structure.
If an observation falls out of the histogram range, the *underflow*
or the *overflow* *cell* is incremented.


***** Direct Slots

# link target 2: <<range-min>>
# link target: <<slot range-min>>


****** Internal Slot: =range-min=                                                :slot:

- Value type: =real=
- Initial value: =NIL=
- Initargs: min
- Allocation: instance


******* Accessors

-----

# link target 2: <<range-min>>
# link target: <<slot-accessor range-min>>


******** Internal Slot Accessor: =range-min=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(range-min object)
#+END_SRC


********* Methods

- (=range-min= (histogram [[class histogram][=histogram=]]))





# link target 2: <<range-max>>
# link target: <<slot range-max>>


****** Internal Slot: =range-max=                                                :slot:

- Value type: =real=
- Initial value: =NIL=
- Initargs: max
- Allocation: instance


******* Accessors

-----

# link target 2: <<range-max>>
# link target: <<slot-accessor range-max>>


******** Internal Slot Accessor: =range-max=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(range-max object)
#+END_SRC


********* Methods

- (=range-max= (histogram [[class histogram][=histogram=]]))





# link target 2: <<range-ext-factor>>
# link target: <<slot range-ext-factor>>


****** Internal Slot: =range-ext-factor=                                         :slot:

- Value type: =real=
- Initial value: =1=
- Initargs: range-ext-factor
- Allocation: instance


******* Description

Factor to expand range by


******* Accessors

-----

# link target 2: <<range-ext-factor>>
# link target: <<slot-accessor range-ext-factor>>


******** Internal Slot Accessor: =range-ext-factor=                       :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(range-ext-factor object)
#+END_SRC


********* Methods

- (=range-ext-factor= (histogram [[class histogram][=histogram=]]))





# link target 2: <<mode>>
# link target: <<slot mode>>


****** Internal Slot: =mode=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: mode
- Allocation: instance


******* Description

integer or float mode for collection.


******* Accessors

-----

# link target 2: <<histogram-mode>>
# link target: <<slot-accessor histogram-mode>>


******** Internal Slot Accessor: =histogram-mode=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(histogram-mode object)
#+END_SRC


********* Methods

- (=histogram-mode= (histogram [[class histogram][=histogram=]]))





# link target 2: <<rng>>
# link target: <<slot rng>>


****** Internal Slot: =rng=                                                      :slot:

- Value type: =fixnum=
- Initial value: =0=
- Initargs: genk
- Allocation: instance


******* Description

Index of random number generator to use


# link target 2: <<num-cells>>
# link target: <<slot num-cells>>


****** Internal Slot: =num-cells=                                                :slot:

- Value type: =fixnum=
- Initial value: =10=
- Initargs: num-cells
- Allocation: instance


******* Description

How many cells to use.


******* Accessors

-----

# link target 2: <<num-cells>>
# link target: <<slot-accessor num-cells>>


******** Internal Slot Accessor: =num-cells=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(num-cells object)
#+END_SRC


********* Methods

- (=num-cells= (histogram [[class histogram][=histogram=]]))





# link target 2: <<cell-size>>
# link target: <<slot cell-size>>


****** Internal Slot: =cell-size=                                                :slot:

- Value type: =real=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Cell size once scale determined.


******* Accessors

-----

# link target 2: <<cell-size>>
# link target: <<slot-accessor cell-size>>


******** Internal Slot Accessor: =cell-size=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(cell-size object)
#+END_SRC


********* Methods

- (=cell-size= (histogram [[class histogram][=histogram=]]))



-----

# link target 2: <<histogram-transformed-p>>
# link target: <<slot-accessor histogram-transformed-p>>


******** Internal Slot Accessor: =histogram-transformed-p=                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(histogram-transformed-p object)
#+END_SRC


********* Methods

- (=histogram-transformed-p= (histogram [[class histogram][=histogram=]]))





# link target 2: <<array>>
# link target: <<slot array>>


****** Inherited Slot: =array=                                                   :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Pre-collected observations or cells


******* Accessors

-----

# link target 2: <<cells>>
# link target: <<slot-accessor cells>>


******** Internal Slot Accessor: =cells=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(cells object)
#+END_SRC


********* Methods

- (=cells= (histogram [[class histogram][=histogram=]]))





# link target 2: <<units>>
# link target: <<slot units>>


****** Internal Slot: =units=                                                    :slot:

- Value type: =string=
- Initial value: ="s"=
- Initargs: units
- Allocation: instance


# link target 2: <<underflow-cell>>
# link target: <<slot underflow-cell>>


****** Internal Slot: =underflow-cell=                                           :slot:

- Value type: =integer=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Description

Number of observations below range-min


******* Accessors

-----

# link target 2: <<underflow-cell>>
# link target: <<slot-accessor underflow-cell>>


******** Internal Slot Accessor: =underflow-cell=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(underflow-cell object)
#+END_SRC


********* Methods

- (=underflow-cell= (histogram [[class histogram][=histogram=]]))





# link target 2: <<overflow-cell>>
# link target: <<slot overflow-cell>>


****** Internal Slot: =overflow-cell=                                            :slot:

- Value type: =integer=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Description

Number of observations above range-max


******* Accessors

-----

# link target 2: <<overflow-cell>>
# link target: <<slot-accessor overflow-cell>>


******** Internal Slot Accessor: =overflow-cell=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(overflow-cell object)
#+END_SRC


********* Methods

- (=overflow-cell= (histogram [[class histogram][=histogram=]]))







***** Indirect Slots

# link target 2: <<sqrsum>>
# link target: <<slot sqrsum>>


****** Internal Slot: =sqrsum=                                                   :slot:

- Value type: =float=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<sum>>
# link target: <<slot sum>>


****** External Slot: =sum=                                                      :slot:

- Value type: =float=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<max>>
# link target: <<slot max>>


****** Inherited Slot: =max=                                                     :slot:

- Value type: =float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<min>>
# link target: <<slot min>>


****** Inherited Slot: =min=                                                     :slot:

- Value type: =float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<count>>
# link target: <<slot count>>


****** Inherited Slot: =count=                                                   :slot:

- Value type: =integer=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~3@/dfv:eng/"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<history-buffer>>
# link target: <<class history-buffer>>


**** External Class: =history-buffer=                                         :class:


***** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class history-buffer][history-buffer]], [[class standard-object][standard
    object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

A class for recording the history of seen objects.
The [[duplicate-p]] method is called with an object and will return true if the object is previously recorded in the history of this buffer.

***** Additional Initialization Arguments


- :size :: an =integer= specifies the size of the history buffer
             (number of previous entities to remember)
- :element-type :: a /type specification/ for the elements
             to be stored in the histire buffer.


***** Direct Slots

# link target 2: <<queue>>
# link target: <<slot queue>>


****** External Slot: =queue=                                                    :slot:

- Value type: =vector-wrap-queue=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<queue>>
# link target: <<slot-accessor queue>>


******** External Slot Accessor: =queue=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(queue object)
#+END_SRC


********* Methods

- (=queue= (history-buffer [[class history-buffer][=history-buffer=]]))
- (=queue= (packet-buffer [[class packet-buffer][=packet-buffer=]]))





# link target 2: <<test>>
# link target: <<slot test>>


****** Internal Slot: =test=                                                     :slot:

- Value type: =t=
- Initial value: =#'EQUALP=
- Initargs: test
- Allocation: instance


******* Description

The test function to compare entities


******* Accessors

-----

# link target 2: <<buffer-test>>
# link target: <<slot-accessor buffer-test>>


******** Internal Slot Accessor: =buffer-test=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(buffer-test object)
#+END_SRC


********* Methods

- (=buffer-test= (history-buffer [[class history-buffer][=history-buffer=]]))





# link target 2: <<key>>
# link target: <<slot key>>


****** Internal Slot: =key=                                                      :slot:

- Value type: =t=
- Initial value: =#'IDENTITY=
- Initargs: key
- Allocation: instance


******* Description

The jey function to use to compare entities.


******* Accessors

-----

# link target 2: <<buffer-key>>
# link target: <<slot-accessor buffer-key>>


******** Internal Slot Accessor: =buffer-key=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(buffer-key object)
#+END_SRC


********* Methods

- (=buffer-key= (history-buffer [[class history-buffer][=history-buffer=]]))








-----

# link target 2: <<ideal-channel>>
# link target: <<class ideal-channel>>


**** External Class: =ideal-channel=                                          :class:


***** Inheritance

- Parent classes:
    [[class channel][channel]]
- Precedence list:
    [[class ideal-channel][ideal-channel]], [[class channel][channel]], [[class
    component][component]], [[class parameter-object][parameter-object]], [[class
    entity-with-signals][entity-with-signals]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    None.


***** Parameters



***** Description

Channel with zero propagation delay, zero
  transmission delay (infinite datarate), and always enabled.


***** Direct Slots



***** Indirect Slots

# link target 2: <<source-gate>>
# link target: <<slot source-gate>>


****** Internal Slot: =source-gate=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: source-gate
- Allocation: instance


******* Description

The gate which sends messages over the channel.


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<indexed-count-recorder>>
# link target: <<class indexed-count-recorder>>


**** External Class: =indexed-count-recorder=                                 :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class indexed-count-recorder][indexed-count-recorder]], [[class scalar
    recorder][scalar-recorder]], [[class result-recorder][result-recorder]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Indexed count records the number of times a
  particular value is received. Values are compare using EQL. If a
  CONS is recieved using [[record]] the =car= is taken as the index
  key and the =cdr= is the amount the count is to be incremented.

  This provides a means e.g. to record the number of packets received
  by source at a destination etc.

  The recorder reports as a statistic with the keys as field names.


***** Direct Slots

# link target 2: <<count>>
# link target: <<slot count>>


****** Inherited Slot: =count=                                                   :slot:

- Value type: =t=
- Initial value: =(MAKE-HASH-TABLE :TEST #'EQUAL)=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<recorded-value>>
# link target: <<slot-accessor recorded-value>>


******** Internal Slot Accessor: =recorded-value=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(recorded-value scalar-recorder)
#+END_SRC


********* Description

Return the value to record for a scalar recorder


********* Methods

- (=recorded-value= (r                    [[class accumulated-time
  recorder][=accumulated-time-recorder=]]))
- (=recorded-value= (indexed-count-recorder                    [[class indexed
  count-recorder][=indexed-count-recorder=]]))
- (=recorded-value= (r [[class timeavg][=timeavg=]]))
- (=recorded-value= (last-value [[class last-value][=last-value=]]))
- (=recorded-value= (recorder [[class mean][=mean=]]))
- (=recorded-value= (sum [[class sum][=sum=]]))
- (=recorded-value= (count-recorder [[class count-recorder][=count
  recorder=]]))







***** Indirect Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~A"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<last-value>>
# link target: <<class last-value>>


**** External Class: =last-value=                                             :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class last-value][last-value]], [[class scalar-recorder][scalar-recorder]],
    [[class result-recorder][result-recorder]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    [[class max-recorder][max-recorder]], [[class min-recorder][min-recorder]]


***** Description

Record the last value received.


***** Direct Slots

# link target 2: <<value>>
# link target: <<slot value>>


****** Internal Slot: =value=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<recorded-value>>
# link target: <<slot-accessor recorded-value>>


******** Internal Slot Accessor: =recorded-value=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(recorded-value scalar-recorder)
#+END_SRC


********* Description

Return the value to record for a scalar recorder


********* Methods

- (=recorded-value= (r                    [[class accumulated-time
  recorder][=accumulated-time-recorder=]]))
- (=recorded-value= (indexed-count-recorder                    [[class indexed
  count-recorder][=indexed-count-recorder=]]))
- (=recorded-value= (r [[class timeavg][=timeavg=]]))
- (=recorded-value= (last-value [[class last-value][=last-value=]]))
- (=recorded-value= (recorder [[class mean][=mean=]]))
- (=recorded-value= (sum [[class sum][=sum=]]))
- (=recorded-value= (count-recorder [[class count-recorder][=count
  recorder=]]))







***** Indirect Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~A"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<mean>>
# link target: <<class mean>>


**** External Class: =mean=                                                   :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class mean][mean]], [[class scalar-recorder][scalar-recorder]], [[class
    result-recorder][result-recorder]], [[class owned-object][owned-object]],
    [[class named-object][named-object]], [[class lens-object][lens-object]],
    [[class standard-object][standard-object]], [[class slot-object][slot-object]],
    [[class t][t]]
- Direct subclasses:
    None.


***** Description

Record the mean of the numeric values received.


***** Direct Slots

# link target 2: <<sum>>
# link target: <<slot sum>>


****** External Slot: =sum=                                                      :slot:

- Value type: =t=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<count>>
# link target: <<slot count>>


****** Inherited Slot: =count=                                                   :slot:

- Value type: =t=
- Initial value: =0=
- Initargs: none
- Allocation: instance




***** Indirect Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~A"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target: <<class message>>


**** External Class: =message=                                                :class:


***** Inheritance

- Parent classes:
    [[class event][event]], [[class owned-object][owned-object]]
- Precedence list:
    [[class message][message]], [[class event][event]], [[class owned-object][owned
    object]], [[class named-object][named-object]], [[class lens-object][lens
    object]], [[class standard-object][standard-object]], [[class slot-object][slot
    object]], [[class t][t]]
- Direct subclasses:
    [[class timer-message][timer-message]], [[class packet][packet]]


***** Description

Messages objects represent events, packets,
commands, jobs, customers or other kinds of entities, depending on the
model domain.


***** Direct Slots

# link target 2: <<creation-time>>
# link target: <<slot creation-time>>


****** External Slot: =creation-time=                                            :slot:

- Value type: =time-type=
- Initial value: =(SIMULATION-TIME)=
- Initargs: none
- Allocation: instance


******* Description

The creation time of the message. With cloned
messages (see [[duplicate]] later), the creation time of the original message
is returned and not the time of the cloning operation. This is
particularly useful when modeling communication protocols, because
many protocols clone the transmitted packages to be able to do
retransmissions and/or segmentation/reassembly.


******* Accessors

-----

# link target 2: <<creation-time>>
# link target: <<slot-accessor creation-time>>


******** External Slot Accessor: =creation-time=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(creation-time object)
#+END_SRC


********* Methods

- (=creation-time= (message [[class message][=message=]]))





# link target 2: <<from>>
# link target: <<slot from>>


****** Internal Slot: =from=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or gate from which message was originally sent.


******* Accessors

-----

# link target 2: <<from>>
# link target: <<slot-accessor from>>


******** Internal Slot Accessor: =from=                                   :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(from object)
#+END_SRC


********* Methods

- (=from= (message [[class message][=message=]]))





# link target 2: <<to>>
# link target: <<slot to>>


****** Internal Slot: =to=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or Gate which finally receices message (after a delay if appropriate)


******* Accessors

-----

# link target 2: <<to>>
# link target: <<slot-accessor to>>


******** Internal Slot Accessor: =to=                                     :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(to object)
#+END_SRC


********* Methods

- (=to= (message [[class message][=message=]]))





# link target 2: <<sent-time>>
# link target: <<slot sent-time>>


****** External Slot: =sent-time=                                                :slot:

- Value type: =time-type=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The simulation time the message was sent.


******* Accessors

-----

# link target 2: <<sent-time>>
# link target: <<slot-accessor sent-time>>


******** External Slot Accessor: =sent-time=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(sent-time object)
#+END_SRC


********* Methods

- (=sent-time= (message [[class message][=message=]]))
- (=sent-time= (event [[class event][=event=]]))





# link target 2: <<timestamp>>
# link target: <<slot timestamp>>


****** External Slot: =timestamp=                                                :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: timestamp
- Allocation: instance


******* Description

Utility time stamp field for user


******* Accessors

-----

# link target 2: <<timestamp>>
# link target: <<slot-accessor timestamp>>


******** External Slot Accessor: =timestamp=                              :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(timestamp object)
#+END_SRC


********* Methods

- (=timestamp= (message [[class message][=message=]]))







***** Indirect Slots

# link target 2: <<root-event>>
# link target: <<slot root-event>>


****** External Slot: =root-event=                                               :slot:

- Value type: =event=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Top level root for cloned messages


# link target 2: <<schedule-id>>
# link target: <<slot schedule-id>>


****** Internal Slot: =schedule-id=                                              :slot:

- Value type: =integer=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Used to ensure events with same time and
   priority are scheduled in order of scheduling


# link target 2: <<priority>>
# link target: <<slot priority>>


****** Internal Slot: =priority=                                                 :slot:

- Value type: =fixnum=
- Initial value: =0=
- Initargs: priority
- Allocation: instance


******* Description

Determines delivery of messages with same arrival time


# link target 2: <<arrival-time>>
# link target: <<slot arrival-time>>


****** External Slot: =arrival-time=                                             :slot:

- Value type: =time-type=
- Initial value: =-1.0d0=
- Initargs: time
- Allocation: instance


******* Description

simulation time at which event is to be handled


# link target 2: <<rank>>
# link target: <<slot rank>>


****** Internal Slot: =rank=                                                     :slot:

- Value type: =fixnum=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Rank in priority queue - used internally for
         efficient removal from queue.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target: <<class module>>


**** External Class: =module=                                                 :class:


***** Inheritance

- Parent classes:
    [[class component][component]]
- Precedence list:
    [[class module][module]], [[class component][component]], [[class parameter
    object][parameter-object]], [[class entity-with-signals][entity-with-signals]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class compound-module][compound-module]]


***** Parameters



***** Description

Base class for all [[module]]s which must have
  metaclass [[module-class]].

Modules are used to implement protocols by specialising on the
following methods.

- [[initialize]] method may be used to specify initial configuration
  of the module after creation but before the simulation starts. It
  may for example send a self message to initiate some process.
- [[handle-message]] is used to receive and process all incoming messages.
- [[send]] is used to send messages out of a gate.
- [[schedule-at]] is used to schedule self messages.


***** Direct Slots

# link target 2: <<gate-slots>>
# link target: <<slot gate-slots>>


****** Internal Slot: =gate-slots=                                               :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash table mapping gate names to [[gate-slot]]
    instances as specified in the =:gates= slot option in the class
    specification of subclasses.


******* Accessors

-----

# link target 2: <<gate-slots>>
# link target: <<slot-accessor gate-slots>>


******** Internal Slot Accessor: =gate-slots=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(gate-slots object)
#+END_SRC


********* Methods

- (=gate-slots= (module [[class module][=module=]]))







***** Indirect Slots

# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<module-class>>
# link target: <<class module-class>>


**** External Class: =module-class=                                           :class:


***** Inheritance

- Parent classes:
    [[class parameter-class][parameter-class]]
- Precedence list:
    [[class module-class][module-class]], [[class parameter-class][parameter
    class]], [[class standard-class][standard-class]], [[class std-class][std
    class]], [[class slot-class][slot-class]], [[class pcl-class][pcl-class]],
    [[class class][class]], [[class dependent-update-mixin][dependent-update
    mixin]], [[class plist-mixin][plist-mixin]], [[class definition-source
    mixin][definition-source-mixin]], [[class standard-specializer][standard
    specializer]], [[class specializer][specializer]], [[class
    metaobject][metaobject]], [[class standard-object][standard-object]], [[class
    slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class compound-module-class][compound-module-class]]

***** Additional Class Options

- gates :: ( (/gate-name/ /direction/ [/size]/)*)

           * /gate-name/ : a =symbol=

           * /direction/ : =(:input | :output | :inout)=

           * /size/ : an =integer=

***** Description


Metaclass for entities with gates. Must be used as
metaclass for [[module]] classes.

The gates class option specified what gates are to be created for
instances of classes of this type. The /gate-name/ specifies the
symbolic name to be used to identify the gate and must be unique for
this module. If /direction/ is specified as =:inout= both input
and output gates will be created. If /size/ is specified an array
of gates will be created. A size of zero can be useful to allow for
the automatic creation of the gates on demand depending on the
connections the module.

***** Direct Slots

# link target 2: <<..25..gatespec>>
# link target: <<slot ..25..gatespec>>


****** Internal Slot: =%gatespec=                                                :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The parsed gate specification used to build gates for this class




***** Indirect Slots

# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The properties for this class


# link target 2: <<slots>>
# link target: <<slot slots>>


****** Internal Slot: =slots=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-slots>>
# link target: <<slot direct-slots>>


****** Slot: =direct-slots=                                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<prototype>>
# link target: <<slot prototype>>


****** Slot: =prototype=                                                         :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<wrapper>>
# link target: <<slot wrapper>>


****** Slot: =wrapper=                                                           :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<incompatible-superclass-list>>
# link target: <<slot incompatible-superclass-list>>


****** Slot: =incompatible-superclass-list=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<can-precede-list>>
# link target: <<slot can-precede-list>>


****** Slot: =can-precede-list=                                                  :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<cpl-available-p>>
# link target: <<slot cpl-available-p>>


****** Slot: =cpl-available-p=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<..25..class-precedence-list>>
# link target: <<slot ..25..class-precedence-list>>


****** Slot: =%class-precedence-list=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<finalized-p>>
# link target: <<slot finalized-p>>


****** Slot: =finalized-p=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<safe-p>>
# link target: <<slot safe-p>>


****** Slot: =safe-p=                                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: safe-p
- Allocation: instance


******* Description



# link target 2: <<..25..documentation>>
# link target: <<slot ..25..documentation>>


****** Slot: =%documentation=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: documentation
- Allocation: instance


******* Description



# link target 2: <<direct-methods>>
# link target: <<slot direct-methods>>


****** Slot: =direct-methods=                                                    :slot:

- Value type: =t=
- Initial value: =(CONS NIL NIL)=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-subclasses>>
# link target: <<slot direct-subclasses>>


****** Slot: =direct-subclasses=                                                 :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-superclasses>>
# link target: <<slot direct-superclasses>>


****** Internal Slot: =direct-superclasses=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target: <<slot class-eq-specializer>>


****** Slot: =class-eq-specializer=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description



# link target 2: <<plist>>
# link target: <<slot plist>>


****** Slot: =plist=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: plist
- Allocation: instance


******* Description



# link target 2: <<source>>
# link target: <<slot source>>


****** Internal Slot: =source=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: definition-source
- Allocation: instance


******* Description



# link target 2: <<..25..type>>
# link target: <<slot ..25..type>>


****** Slot: =%type=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description






-----

# link target 2: <<mt-random-state>>
# link target: <<class mt-random-state>>


**** External Class: =mt-random-state=                                        :class:


***** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class mt-random-state][mt-random-state]], [[class standard-object][standard
    object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.

***** Description


The Mersenne Twister is an algorithm for generating random numbers.  It
was designed with consideration of the flaws in various other generators.
The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
are far greater.  The generator is also fast; it avoids multiplication and
division, and it benefits from caches and pipelines.  For more information
see the inventors' web page at http://www.math.keio.ac.jp/~matumoto/emt.html

***** Reference


M. Matsumoto and T. Nishimura, 'Mersenne Twister: A 623-Dimensionally
Equidistributed Uniform Pseudo-Random Number Generator', ACM Transactions on
Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.

***** Direct Slots

# link target 2: <<arr>>
# link target: <<slot arr>>


****** Internal Slot: =arr=                                                      :slot:

- Value type: =array=
- Initial value: =(MAKE-ARRAY +MT-N+ :ELEMENT-TYPE '(UINT 32))=
- Initargs: none
- Allocation: instance


# link target 2: <<mti>>
# link target: <<slot mti>>


****** Internal Slot: =mti=                                                      :slot:

- Value type: =fixnum=
- Initial value: =+MT-N+=
- Initargs: none
- Allocation: instance


# link target 2: <<seed>>
# link target: <<slot seed>>


****** External Slot: =seed=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: seed
- Allocation: instance


******* Description

The initial seed value.


# link target 2: <<count>>
# link target: <<slot count>>


****** Inherited Slot: =count=                                                   :slot:

- Value type: =t=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Description

The number of random values extracted.





-----

# link target 2: <<named-object>>
# link target: <<class named-object>>


**** External Class: =named-object=                                           :class:


***** Inheritance

- Parent classes:
    [[class lens-object][lens-object]]
- Precedence list:
    [[class named-object][named-object]], [[class lens-object][lens-object]],
    [[class standard-object][standard-object]], [[class slot-object][slot-object]],
    [[class t][t]]
- Direct subclasses:
    [[class simulation][simulation]], [[class owned-object][owned-object]]


***** Description

Not documented.


***** Direct Slots

# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.


******* Accessors

-----

# link target 2: <<name>>
# link target: <<slot-accessor name>>


******** External Slot Accessor: =name=                                   :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(name object)
#+END_SRC


********* Methods

- (=name= (link [[class gate][=gate=]]))
- (=name= (named-object [[class named-object][=named-object=]]))





# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


******* Accessors

-----

# link target 2: <<index>>
# link target: <<slot-accessor index>>


******** External Slot Accessor: =index=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(index object)
#+END_SRC


********* Methods

- (=index= (named-object [[class named-object][=named-object=]]))








-----

# link target: <<class network>>


**** External Class: =network=                                                :class:


***** Inheritance

- Parent classes:
    [[class compound-module][compound-module]]
- Precedence list:
    [[class network][network]], [[class compound-module][compound-module]], [[class
    module][module]], [[class component][component]], [[class parameter
    object][parameter-object]], [[class entity-with-signals][entity-with-signals]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Parameters



***** Description

Base class for networks. This is the required type
  for the top-level [[compound-module]] of a simulation network and it
  is required that it has no gate specification. It is specified in
  the =network= simulation parameter.


***** Direct Slots

# link target 2: <<gate-slots>>
# link target: <<slot gate-slots>>


****** Internal Slot: =gate-slots=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance




***** Indirect Slots

# link target 2: <<channels>>
# link target: <<slot channels>>


****** Internal Slot: =channels=                                                 :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<submodules>>
# link target: <<slot submodules>>


****** Internal Slot: =submodules=                                               :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<owned-object>>
# link target: <<class owned-object>>


**** External Class: =owned-object=                                           :class:


***** Inheritance

- Parent classes:
    [[class named-object][named-object]]
- Precedence list:
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class result-recorder][result-recorder]], [[class gate-slot][gate-slot]],
    [[class gate][gate]], [[class message][message]], [[class entity-with
    signals][entity-with-signals]]


***** Description

Not documented.


***** Direct Slots

# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


******* Accessors

-----

# link target 2: <<owner>>
# link target: <<slot-accessor owner>>


******** External Slot Accessor: =owner=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(owner object)
#+END_SRC


********* Methods

- (=owner= (owned-object [[class owned-object][=owned-object=]]))







***** Indirect Slots

# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<packet>>
# link target: <<class packet>>


**** External Class: =packet=                                                 :class:


***** Inheritance

- Parent classes:
    [[class message][message]]
- Precedence list:
    [[class packet][packet]], [[class message][message]], [[class event][event]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Representation of network packets. Packets are
   messages which may take time to deliver over transmission links.

Protocol [[modules]] will typically [[encapsulate]] a packet from an
upper level in a packet message type, adding in any additional fields
before passing to a lower level]]. On receiving their packet from a
lower level they can call [[decapsulate]] to get the original
encapsulated packet to pass on to upper levels. If a packet is to be
sent to multiple destinations then [[duplicate]] must be called to
create multiple copies as required.


***** Direct Slots

# link target 2: <<encapsulated-packet>>
# link target: <<slot encapsulated-packet>>


****** Internal Slot: =encapsulated-packet=                                      :slot:

- Value type: =packet=
- Initial value: =NIL=
- Initargs: encapsulated-packet
- Allocation: instance


******* Description

Higher level encapsulated protocol packet.


# link target 2: <<duration>>
# link target: <<slot duration>>


****** External Slot: =duration=                                                 :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: none
- Allocation: instance


******* Description

Duration of last transmission


******* Accessors

-----

# link target 2: <<duration>>
# link target: <<slot-accessor duration>>


******** External Slot Accessor: =duration=                               :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(duration object)
#+END_SRC


********* Methods

- (=duration= (packet [[class packet][=packet=]]))





# link target 2: <<control-info>>
# link target: <<slot control-info>>


****** External Slot: =control-info=                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: control-info
- Allocation: instance


******* Description

Additional data to be passed with packet between
    protocol layers.


******* Accessors

-----

# link target 2: <<control-info>>
# link target: <<slot-accessor control-info>>


******** External Slot Accessor: =control-info=                           :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(control-info object)
#+END_SRC


********* Methods

- (=control-info= (packet [[class packet][=packet=]]))





# link target 2: <<reception-start-p>>
# link target: <<slot reception-start-p>>


****** Internal Slot: =reception-start-p=                                        :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: deliver-on-reception-start
- Allocation: instance


******* Description

Identify whether this packet represents the start
or the end of the reception after the packet travelled through a
channel with a data rate. This flag is controlled by the
deliver-on-reception-start flag of the receiving gate.


******* Accessors

-----

# link target 2: <<reception-start-p>>
# link target: <<slot-accessor reception-start-p>>


******** Internal Slot Accessor: =reception-start-p=                      :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(reception-start-p object)
#+END_SRC


********* Methods

- (=reception-start-p= (packet [[class packet][=packet=]]))





# link target 2: <<bit-error-p>>
# link target: <<slot bit-error-p>>


****** External Slot: =bit-error-p=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The result of error modelling after the packet is
sent through a channel that has a nonzero packet error rate (PER) or
bit error rate (BER). It is up to the receiver to examine this flag
after having received the packet, and to act upon it.


******* Accessors

-----

# link target 2: <<bit-error-p>>
# link target: <<slot-accessor bit-error-p>>


******** External Slot Accessor: =bit-error-p=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(bit-error-p object)
#+END_SRC


********* Methods

- (=bit-error-p= (packet [[class packet][=packet=]]))







***** Indirect Slots

# link target 2: <<timestamp>>
# link target: <<slot timestamp>>


****** External Slot: =timestamp=                                                :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: timestamp
- Allocation: instance


******* Description

Utility time stamp field for user


# link target 2: <<to>>
# link target: <<slot to>>


****** Internal Slot: =to=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or Gate which finally receices message (after a delay if appropriate)


# link target 2: <<from>>
# link target: <<slot from>>


****** Internal Slot: =from=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or gate from which message was originally sent.


# link target 2: <<creation-time>>
# link target: <<slot creation-time>>


****** External Slot: =creation-time=                                            :slot:

- Value type: =time-type=
- Initial value: =(SIMULATION-TIME)=
- Initargs: none
- Allocation: instance


******* Description

The creation time of the message. With cloned
messages (see [[duplicate]] later), the creation time of the original message
is returned and not the time of the cloning operation. This is
particularly useful when modeling communication protocols, because
many protocols clone the transmitted packages to be able to do
retransmissions and/or segmentation/reassembly.


# link target 2: <<root-event>>
# link target: <<slot root-event>>


****** External Slot: =root-event=                                               :slot:

- Value type: =event=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Top level root for cloned messages


# link target 2: <<schedule-id>>
# link target: <<slot schedule-id>>


****** Internal Slot: =schedule-id=                                              :slot:

- Value type: =integer=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Used to ensure events with same time and
   priority are scheduled in order of scheduling


# link target 2: <<priority>>
# link target: <<slot priority>>


****** Internal Slot: =priority=                                                 :slot:

- Value type: =fixnum=
- Initial value: =0=
- Initargs: priority
- Allocation: instance


******* Description

Determines delivery of messages with same arrival time


# link target 2: <<arrival-time>>
# link target: <<slot arrival-time>>


****** External Slot: =arrival-time=                                             :slot:

- Value type: =time-type=
- Initial value: =-1.0d0=
- Initargs: time
- Allocation: instance


******* Description

simulation time at which event is to be handled


# link target 2: <<sent-time>>
# link target: <<slot sent-time>>


****** External Slot: =sent-time=                                                :slot:

- Value type: =double-float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The simulation time the message was sent.


# link target 2: <<rank>>
# link target: <<slot rank>>


****** Internal Slot: =rank=                                                     :slot:

- Value type: =fixnum=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Rank in priority queue - used internally for
         efficient removal from queue.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<packet-buffer>>
# link target: <<class packet-buffer>>


**** External Class: =packet-buffer=                                          :class:


***** Inheritance

- Parent classes:
    [[class entity-with-signals][entity-with-signals]], [[class parameter
    object][parameter-object]]
- Precedence list:
    [[class packet-buffer][packet-buffer]], [[class entity-with-signals][entity
    with-signals]], [[class owned-object][owned-object]], [[class named
    object][named-object]], [[class lens-object][lens-object]], [[class parameter
    object][parameter-object]], [[class standard-object][standard-object]], [[class
    slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Parameters

- buffer-size :: a =fixnum=. Default: =32=. max buffer size in messages
- buffer-size-bytes :: a =fixnum=.  max size in bytes

***** Description

A packet buffer emplements the queue interface for
[[packet]]s using a timestamped queue. [[dequeue]] and [[peek]] from a
[[timestamped-queue]] returns this time as a second value. It also
keeps track of the average queue duration which can be obtained using
[[average-queue-time]].

It keeps track of the buffer size which may be set using the
=buffer-size= or =buffer-size-bytes= parameters. [[packet]]s are
dropped if either maximum buffer size is exceeded and the =drop=
signal will be generated with the dropped [[packet]] as the
argument. Every time the queue length is changed the =buffer-length=
and =buffer-time= events are generated with the buffer and the
duration the packet was in the buffer respectively.

 


***** Direct Slots

# link target 2: <<queue>>
# link target: <<slot queue>>


****** External Slot: =queue=                                                    :slot:

- Value type: =timestamped-queue=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<queue>>
# link target: <<slot-accessor queue>>


******** External Slot Accessor: =queue=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(queue object)
#+END_SRC


********* Methods

- (=queue= (history-buffer [[class history-buffer][=history-buffer=]]))
- (=queue= (packet-buffer [[class packet-buffer][=packet-buffer=]]))





# link target 2: <<buffer-size>>
# link target: <<slot buffer-size>>


****** External Slot: =buffer-size=                                              :slot:

- Value type: =fixnum=
- Initial value: =32=
- Initargs: buffer-size
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

max buffer size in messages


******* Accessors

-----

# link target 2: <<buffer-size>>
# link target: <<slot-accessor buffer-size>>


******** External Slot Accessor: =buffer-size=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(buffer-size object)
#+END_SRC


********* Methods

- (=buffer-size= (packet-buffer [[class packet-buffer][=packet-buffer=]]))





# link target 2: <<buffer-size-bytes>>
# link target: <<slot buffer-size-bytes>>


****** External Slot: =buffer-size-bytes=                                        :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: buffer-size-bytes
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

max size in bytes


******* Accessors

-----

# link target 2: <<buffer-size-bytes>>
# link target: <<slot-accessor buffer-size-bytes>>


******** External Slot Accessor: =buffer-size-bytes=                      :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(buffer-size-bytes object)
#+END_SRC


********* Methods

- (=buffer-size-bytes= (packet-buffer [[class packet-buffer][=packet
  buffer=]]))





# link target 2: <<byte-length>>
# link target: <<slot byte-length>>


****** External Slot: =byte-length=                                              :slot:

- Value type: =fixnum=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<byte-length>>
# link target: <<slot-accessor byte-length>>


******** External Slot Accessor: =byte-length=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(byte-length entity)
#+END_SRC


********* Description

Return the length in whole octets (8 bit bytes) of
  an =entity=. For a [[packet]] the length should include the length
  of all encapsulated packets together with its overhead.


********* Methods

- (=byte-length= (packet-buffer [[class packet-buffer][=packet-buffer=]]))
- (=byte-length= (v [[class bit-vector][=bit-vector=]]))







***** Indirect Slots

# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list





-----

# link target 2: <<parameter-class>>
# link target: <<class parameter-class>>


**** External Class: =parameter-class=                                        :class:


***** Inheritance

- Parent classes:
    [[class standard-class][standard-class]]
- Precedence list:
    [[class parameter-class][parameter-class]], [[class standard-class][standard
    class]], [[class std-class][std-class]], [[class slot-class][slot-class]],
    [[class pcl-class][pcl-class]], [[class class][class]], [[class dependent
    update-mixin][dependent-update-mixin]], [[class plist-mixin][plist-mixin]],
    [[class definition-source-mixin][definition-source-mixin]], [[class standard
    specializer][standard-specializer]], [[class specializer][specializer]],
    [[class metaobject][metaobject]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class module-class][module-class]]


***** Description

Metaclass for classes which have slots initialised
  from an external parameter source.

***** Additional class options


- properties :: an /alist/

The /properties/ class option specifies the default set of properties
all classes of this metaclass will take as a default. These are in
addiiton to the instance properties that may be specified. The
instance properties take precedence.

***** Additional slot options


- parameter :: a =boolean=
- volatile :: a =boolean=
- properties :: an /alist/

If /parameter/ is true then this is a parameter slot and the value for
this slot will be initialised from the simulation configuration file
as a priority over the default value specified in the =:initform= slot
option. If /volatile/ is specified for a parameter slot then the
parameter will be evaluated upon every initialisation allowing random
initialisation for different instances. The /properties/ of a
parameter slot specify additional properties in an alist. By default
the following properties are currently understood.

- format :: specifies a format form to used in [[parse-input]] when reading the parameter - overrides the default reading format for the slot type.



***** Direct Slots

# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The properties for this class


******* Accessors

-----

# link target 2: <<properties>>
# link target: <<slot-accessor properties>>


******** Internal Slot Accessor: =properties=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(properties instance)
#+END_SRC


********* Description

Return an a-list of properties associated with an
  instance of a [[parameter-object]]. These may be used to specify
  parameters that may be used outside the simulation itself such as
  statistics gathers for components or display properties etc. The may
  be specified on a per class or per instance basis with instance
  overriding class values.


********* Methods

- (=properties= (obj [[class parameter-object][=parameter-object=]]))
- (=properties= (parameter-class [[class parameter-class][=parameter-class=]]))







***** Indirect Slots

# link target 2: <<slots>>
# link target: <<slot slots>>


****** Internal Slot: =slots=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-slots>>
# link target: <<slot direct-slots>>


****** Slot: =direct-slots=                                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<prototype>>
# link target: <<slot prototype>>


****** Slot: =prototype=                                                         :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<wrapper>>
# link target: <<slot wrapper>>


****** Slot: =wrapper=                                                           :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<incompatible-superclass-list>>
# link target: <<slot incompatible-superclass-list>>


****** Slot: =incompatible-superclass-list=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<can-precede-list>>
# link target: <<slot can-precede-list>>


****** Slot: =can-precede-list=                                                  :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<cpl-available-p>>
# link target: <<slot cpl-available-p>>


****** Slot: =cpl-available-p=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<..25..class-precedence-list>>
# link target: <<slot ..25..class-precedence-list>>


****** Slot: =%class-precedence-list=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<finalized-p>>
# link target: <<slot finalized-p>>


****** Slot: =finalized-p=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<safe-p>>
# link target: <<slot safe-p>>


****** Slot: =safe-p=                                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: safe-p
- Allocation: instance


******* Description



# link target 2: <<..25..documentation>>
# link target: <<slot ..25..documentation>>


****** Slot: =%documentation=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: documentation
- Allocation: instance


******* Description



# link target 2: <<direct-methods>>
# link target: <<slot direct-methods>>


****** Slot: =direct-methods=                                                    :slot:

- Value type: =t=
- Initial value: =(CONS NIL NIL)=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-subclasses>>
# link target: <<slot direct-subclasses>>


****** Slot: =direct-subclasses=                                                 :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<direct-superclasses>>
# link target: <<slot direct-superclasses>>


****** Internal Slot: =direct-superclasses=                                      :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target: <<slot class-eq-specializer>>


****** Slot: =class-eq-specializer=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description



# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description



# link target 2: <<plist>>
# link target: <<slot plist>>


****** Slot: =plist=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: plist
- Allocation: instance


******* Description



# link target 2: <<source>>
# link target: <<slot source>>


****** Internal Slot: =source=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: definition-source
- Allocation: instance


******* Description



# link target 2: <<..25..type>>
# link target: <<slot ..25..type>>


****** Slot: =%type=                                                             :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description






-----

# link target 2: <<parameter-object>>
# link target: <<class parameter-object>>


**** External Class: =parameter-object=                                       :class:


***** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class parameter-object][parameter-object]], [[class standard-object][standard
    object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    [[class packet-buffer][packet-buffer]], [[class component][component]], [[class
    simulation][simulation]]


***** Parameters



***** Description

Base class for all components which can have slots initialoised from
parameters. See the [[parameter-class]] metaclass for the additional
slot options available and their affect. The =:properties= /initarg/
may be used to specify instance specific properties (see
[[properties]]).


***** Direct Slots

# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list





-----

# link target 2: <<simulation>>
# link target: <<class simulation>>


**** External Class: =simulation=                                             :class:


***** Inheritance

- Parent classes:
    [[class named-object][named-object]], [[class parameter-object][parameter
    object]]
- Precedence list:
    [[class simulation][simulation]], [[class named-object][named-object]], [[class
    lens-object][lens-object]], [[class parameter-object][parameter-object]],
    [[class standard-object][standard-object]], [[class slot-object][slot-object]],
    [[class t][t]]
- Direct subclasses:
    None.


***** Parameters

- num-rngs :: a =fixnum=. Default: =1=. Total number of rngs for this simulation
- rng-class :: a =symbol=. Default: ='MT-RANDOM-STATE=. Class for rng's
- warmup-period :: a =time-type=. Default: =0=. Warmup period for statistics collection
- cpu-time-limit :: a =time-type=. Default: =300=. Max cpu time for run.
- sim-time-limit :: a =time-type=. Default: =(* 100 60 60 60)=. Maximum simulation run time
- network :: a =symbol=.  Specified Network type parameter

***** Description

The main discrete time event simulation class reads
  global parameters, creates the network being simulated and manages
  the queue of events for the simulation. 


***** Direct Slots

# link target 2: <<clock>>
# link target: <<slot clock>>


****** Internal Slot: =clock=                                                    :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: start-time
- Allocation: instance


******* Description

Simulation virtual time


******* Accessors

-----

# link target 2: <<clock>>
# link target: <<slot-accessor clock>>


******** Internal Slot Accessor: =clock=                                  :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(clock object)
#+END_SRC


********* Methods

- (=clock= (simulation [[class simulation][=simulation=]]))





# link target 2: <<halted>>
# link target: <<slot halted>>


****** Internal Slot: =halted=                                                   :slot:

- Value type: =boolean=
- Initial value: =T=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<halted>>
# link target: <<slot-accessor halted>>


******** Internal Slot Accessor: =halted=                                 :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(halted object)
#+END_SRC


********* Methods

- (=halted= (simulation [[class simulation][=simulation=]]))





# link target 2: <<thread>>
# link target: <<slot thread>>


****** Internal Slot: =thread=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Thread running simulation


******* Accessors

-----

# link target 2: <<simulation-thread>>
# link target: <<slot-accessor simulation-thread>>


******** Internal Slot Accessor: =simulation-thread=                      :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(simulation-thread object)
#+END_SRC


********* Methods

- (=simulation-thread= (simulation [[class simulation][=simulation=]]))





# link target 2: <<last-schedule-id>>
# link target: <<slot last-schedule-id>>


****** Internal Slot: =last-schedule-id=                                         :slot:

- Value type: =integer=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<event-queue>>
# link target: <<slot event-queue>>


****** Internal Slot: =event-queue=                                              :slot:

- Value type: =t=
- Initial value: =(MAKE-BINARY-HEAP :INITIAL-SIZE 1024 :EXTEND-SIZE 1.4        
                            :ELEMENT-TYPE 'EVENT :COMP-FN #'EVENT< :INDEX      
                              #'EVENT-RANK)=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<event-queue>>
# link target: <<slot-accessor event-queue>>


******** Internal Slot Accessor: =event-queue=                            :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(event-queue object)
#+END_SRC


********* Methods

- (=event-queue= (simulation [[class simulation][=simulation=]]))





# link target 2: <<configuration>>
# link target: <<slot configuration>>


****** External Slot: =configuration=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: configuration
- Allocation: instance


******* Description

Configuration data used for simulation


******* Accessors

-----

# link target 2: <<configuration>>
# link target: <<slot-accessor configuration>>


******** External Slot Accessor: =configuration=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(configuration instance)
#+END_SRC


********* Description

Return the configuration trie with an instance. By
  default this will be the configuration read at the start of the
  simulation.


********* Methods

- (=configuration= (object [[class t][=t=]]))
- (=configuration= (instance [[class owned-object][=owned-object=]]))
- (=configuration= (simulation [[class simulation][=simulation=]]))





# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Top level array of rngs


******* Accessors

-----

# link target 2: <<rng-map>>
# link target: <<slot-accessor rng-map>>


******** External Slot Accessor: =rng-map=                                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(rng-map context)
#+END_SRC


********* Methods

- (=rng-map= (component [[class component][=component=]]))
- (=rng-map= (simulation [[class simulation][=simulation=]]))
- (=rng-map= (context (eql nil)))





# link target 2: <<seed-set>>
# link target: <<slot seed-set>>


****** Internal Slot: =seed-set=                                                 :slot:

- Value type: =integer=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Seed set used in this simulation


******* Accessors

-----

# link target 2: <<seed-set>>
# link target: <<slot-accessor seed-set>>


******** Internal Slot Accessor: =seed-set=                               :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(seed-set object)
#+END_SRC


********* Methods

- (=seed-set= (simulation [[class simulation][=simulation=]]))





# link target 2: <<num-rngs>>
# link target: <<slot num-rngs>>


****** Internal Slot: =num-rngs=                                                 :slot:

- Value type: =fixnum=
- Initial value: =1=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Total number of rngs for this simulation


******* Accessors

-----

# link target 2: <<num-rngs>>
# link target: <<slot-accessor num-rngs>>


******** Internal Slot Accessor: =num-rngs=                               :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(num-rngs object)
#+END_SRC


********* Methods

- (=num-rngs= (simulation [[class simulation][=simulation=]]))





# link target 2: <<rng-class>>
# link target: <<slot rng-class>>


****** Internal Slot: =rng-class=                                                :slot:

- Value type: =symbol=
- Initial value: ='MT-RANDOM-STATE=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Class for rng's


# link target 2: <<warmup-period>>
# link target: <<slot warmup-period>>


****** Internal Slot: =warmup-period=                                            :slot:

- Value type: =time-type=
- Initial value: =0=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Warmup period for statistics collection


******* Accessors

-----

# link target 2: <<warmup-period>>
# link target: <<slot-accessor warmup-period>>


******** Internal Slot Accessor: =warmup-period=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(warmup-period object)
#+END_SRC


********* Methods

- (=warmup-period= (simulation [[class simulation][=simulation=]]))





# link target 2: <<cpu-time-limit>>
# link target: <<slot cpu-time-limit>>


****** External Slot: =cpu-time-limit=                                           :slot:

- Value type: =time-type=
- Initial value: =300=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Max cpu time for run.


******* Accessors

-----

# link target 2: <<cpu-time-limit>>
# link target: <<slot-accessor cpu-time-limit>>


******** External Slot Accessor: =cpu-time-limit=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(cpu-time-limit object)
#+END_SRC


********* Methods

- (=cpu-time-limit= (simulation [[class simulation][=simulation=]]))





# link target 2: <<sim-time-limit>>
# link target: <<slot sim-time-limit>>


****** External Slot: =sim-time-limit=                                           :slot:

- Value type: =time-type=
- Initial value: =(* 100 60 60 60)=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Maximum simulation run time


******* Accessors

-----

# link target 2: <<sim-time-limit>>
# link target: <<slot-accessor sim-time-limit>>


******** External Slot Accessor: =sim-time-limit=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(sim-time-limit object)
#+END_SRC


********* Methods

- (=sim-time-limit= (simulation [[class simulation][=simulation=]]))





# link target: <<slot network>>


****** External Slot: =network=                                                  :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance
- Parameter: t
- Properties: nil


******* Description

Specified Network type parameter


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<network-instance>>
# link target: <<slot network-instance>>


****** Internal Slot: =network-instance=                                         :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Actual network instance in this simulation


******* Accessors

-----

# link target: <<slot-accessor network>>


******** External Slot Accessor: =network=                                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(network object)
#+END_SRC


********* Methods

- (=network= (instance [[class t][=t=]]))
- (=network= (simulation [[class simulation][=simulation=]]))





# link target 2: <<vector-stream>>
# link target: <<slot vector-stream>>


****** Internal Slot: =vector-stream=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: vector-stream
- Allocation: instance


******* Description

Destination stream for vector results


******* Accessors

-----

# link target 2: <<vector-stream>>
# link target: <<slot-accessor vector-stream>>


******** Internal Slot Accessor: =vector-stream=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(vector-stream object)
#+END_SRC


********* Methods

- (=vector-stream= (simulation [[class simulation][=simulation=]]))





# link target 2: <<scalar-stream>>
# link target: <<slot scalar-stream>>


****** Internal Slot: =scalar-stream=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: scalar-stream
- Allocation: instance


******* Description

Destination stream for scalar results


******* Accessors

-----

# link target 2: <<scalar-stream>>
# link target: <<slot-accessor scalar-stream>>


******** Internal Slot Accessor: =scalar-stream=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(scalar-stream object)
#+END_SRC


********* Methods

- (=scalar-stream= (simulation [[class simulation][=simulation=]]))







***** Indirect Slots

# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list





-----

# link target 2: <<simulation-condition>>
# link target: <<class simulation-condition>>


**** External Class: =simulation-condition=                                   :class:


***** Inheritance

- Parent classes:
    [[class condition][condition]]
- Precedence list:
    [[class simulation-condition][simulation-condition]], [[class
    condition][condition]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Not documented.


***** Direct Slots




-----

# link target 2: <<stddev>>
# link target: <<class stddev>>


**** External Class: =stddev=                                                 :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class stddev][stddev]], [[class scalar-recorder][scalar-recorder]], [[class
    result-recorder][result-recorder]], [[class owned-object][owned-object]],
    [[class named-object][named-object]], [[class lens-object][lens-object]],
    [[class standard-object][standard-object]], [[class slot-object][slot-object]],
    [[class t][t]]
- Direct subclasses:
    [[class histogram][histogram]], [[class weighted-stddev][weighted-stddev]]


***** Description

Output basic statistics (cound,min,max,mean and
  stddev) of numeric values received.


***** Direct Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~3@/dfv:eng/"=
- Initargs: none
- Allocation: instance


# link target 2: <<count>>
# link target: <<slot count>>


****** Inherited Slot: =count=                                                   :slot:

- Value type: =integer=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<result-count>>
# link target: <<slot-accessor result-count>>


******** Internal Slot Accessor: =result-count=                           :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(result-count object)
#+END_SRC


********* Methods

- (=result-count= (stddev [[class stddev][=stddev=]]))





# link target 2: <<min>>
# link target: <<slot min>>


****** Inherited Slot: =min=                                                     :slot:

- Value type: =float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<result-min>>
# link target: <<slot-accessor result-min>>


******** Internal Slot Accessor: =result-min=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(result-min object)
#+END_SRC


********* Methods

- (=result-min= (stddev [[class stddev][=stddev=]]))





# link target 2: <<max>>
# link target: <<slot max>>


****** Inherited Slot: =max=                                                     :slot:

- Value type: =float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<result-max>>
# link target: <<slot-accessor result-max>>


******** Internal Slot Accessor: =result-max=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(result-max object)
#+END_SRC


********* Methods

- (=result-max= (stddev [[class stddev][=stddev=]]))





# link target 2: <<sum>>
# link target: <<slot sum>>


****** External Slot: =sum=                                                      :slot:

- Value type: =float=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<result-sum>>
# link target: <<slot-accessor result-sum>>


******** Internal Slot Accessor: =result-sum=                             :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(result-sum object)
#+END_SRC


********* Methods

- (=result-sum= (stddev [[class stddev][=stddev=]]))





# link target 2: <<sqrsum>>
# link target: <<slot sqrsum>>


****** Internal Slot: =sqrsum=                                                   :slot:

- Value type: =float=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<result-sqrsum>>
# link target: <<slot-accessor result-sqrsum>>


******** Internal Slot Accessor: =result-sqrsum=                          :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(result-sqrsum object)
#+END_SRC


********* Methods

- (=result-sqrsum= (stddev [[class stddev][=stddev=]]))







***** Indirect Slots

# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<sum>>
# link target: <<class sum>>


**** External Class: =sum=                                                    :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class sum][sum]], [[class scalar-recorder][scalar-recorder]], [[class result
    recorder][result-recorder]], [[class owned-object][owned-object]], [[class
    named-object][named-object]], [[class lens-object][lens-object]], [[class
    standard-object][standard-object]], [[class slot-object][slot-object]], [[class
    t][t]]
- Direct subclasses:
    None.


***** Description

Record the sum of the numeric values received.


***** Direct Slots

# link target 2: <<sum>>
# link target: <<slot sum>>


****** External Slot: =sum=                                                      :slot:

- Value type: =t=
- Initial value: =0=
- Initargs: none
- Allocation: instance


******* Accessors

-----

# link target 2: <<recorded-value>>
# link target: <<slot-accessor recorded-value>>


******** Internal Slot Accessor: =recorded-value=                         :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(recorded-value scalar-recorder)
#+END_SRC


********* Description

Return the value to record for a scalar recorder


********* Methods

- (=recorded-value= (r                    [[class accumulated-time
  recorder][=accumulated-time-recorder=]]))
- (=recorded-value= (indexed-count-recorder                    [[class indexed
  count-recorder][=indexed-count-recorder=]]))
- (=recorded-value= (r [[class timeavg][=timeavg=]]))
- (=recorded-value= (last-value [[class last-value][=last-value=]]))
- (=recorded-value= (recorder [[class mean][=mean=]]))
- (=recorded-value= (sum [[class sum][=sum=]]))
- (=recorded-value= (count-recorder [[class count-recorder][=count
  recorder=]]))







***** Indirect Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~A"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<timeavg>>
# link target: <<class timeavg>>


**** External Class: =timeavg=                                                :class:


***** Inheritance

- Parent classes:
    [[class scalar-recorder][scalar-recorder]]
- Precedence list:
    [[class timeavg][timeavg]], [[class scalar-recorder][scalar-recorder]], [[class
    result-recorder][result-recorder]], [[class owned-object][owned-object]],
    [[class named-object][named-object]], [[class lens-object][lens-object]],
    [[class standard-object][standard-object]], [[class slot-object][slot-object]],
    [[class t][t]]
- Direct subclasses:
    None.


***** Description

Record the time averaged value received.


***** Direct Slots

# link target 2: <<start-time>>
# link target: <<slot start-time>>


****** Internal Slot: =start-time=                                               :slot:

- Value type: =timetype=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


# link target 2: <<last-time>>
# link target: <<slot last-time>>


****** Internal Slot: =last-time=                                                :slot:

- Value type: =timetype=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<weighted-sum>>
# link target: <<slot weighted-sum>>


****** Internal Slot: =weighted-sum=                                             :slot:

- Value type: =real=
- Initial value: =0=
- Initargs: none
- Allocation: instance


# link target 2: <<last-value>>
# link target: <<slot last-value>>


****** External Slot: =last-value=                                               :slot:

- Value type: =real=
- Initial value: =0=
- Initargs: none
- Allocation: instance




***** Indirect Slots

# link target 2: <<output-format>>
# link target: <<slot output-format>>


****** Internal Slot: =output-format=                                            :slot:

- Value type: =t=
- Initial value: ="~A"=
- Initargs: format
- Allocation: instance


******* Description

Format to use when outputing recorded units


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<timer-message>>
# link target: <<class timer-message>>


**** External Class: =timer-message=                                          :class:


***** Inheritance

- Parent classes:
    [[class message][message]]
- Precedence list:
    [[class timer-message][timer-message]], [[class message][message]], [[class
    event][event]], [[class owned-object][owned-object]], [[class named
    object][named-object]], [[class lens-object][lens-object]], [[class standard
    object][standard-object]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Class for timer messages. Components which subclass
  [[with-timers]] will receive these messages via [[handle-timer]]


***** Direct Slots



***** Indirect Slots

# link target 2: <<timestamp>>
# link target: <<slot timestamp>>


****** External Slot: =timestamp=                                                :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: timestamp
- Allocation: instance


******* Description

Utility time stamp field for user


# link target 2: <<to>>
# link target: <<slot to>>


****** Internal Slot: =to=                                                       :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or Gate which finally receices message (after a delay if appropriate)


# link target 2: <<from>>
# link target: <<slot from>>


****** Internal Slot: =from=                                                     :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Module or gate from which message was originally sent.


# link target 2: <<creation-time>>
# link target: <<slot creation-time>>


****** External Slot: =creation-time=                                            :slot:

- Value type: =time-type=
- Initial value: =(SIMULATION-TIME)=
- Initargs: none
- Allocation: instance


******* Description

The creation time of the message. With cloned
messages (see [[duplicate]] later), the creation time of the original message
is returned and not the time of the cloning operation. This is
particularly useful when modeling communication protocols, because
many protocols clone the transmitted packages to be able to do
retransmissions and/or segmentation/reassembly.


# link target 2: <<root-event>>
# link target: <<slot root-event>>


****** External Slot: =root-event=                                               :slot:

- Value type: =event=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Top level root for cloned messages


# link target 2: <<schedule-id>>
# link target: <<slot schedule-id>>


****** Internal Slot: =schedule-id=                                              :slot:

- Value type: =integer=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Used to ensure events with same time and
   priority are scheduled in order of scheduling


# link target 2: <<priority>>
# link target: <<slot priority>>


****** Internal Slot: =priority=                                                 :slot:

- Value type: =fixnum=
- Initial value: =0=
- Initargs: priority
- Allocation: instance


******* Description

Determines delivery of messages with same arrival time


# link target 2: <<arrival-time>>
# link target: <<slot arrival-time>>


****** External Slot: =arrival-time=                                             :slot:

- Value type: =time-type=
- Initial value: =-1.0d0=
- Initargs: time
- Allocation: instance


******* Description

simulation time at which event is to be handled


# link target 2: <<sent-time>>
# link target: <<slot sent-time>>


****** External Slot: =sent-time=                                                :slot:

- Value type: =double-float=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

The simulation time the message was sent.


# link target 2: <<rank>>
# link target: <<slot rank>>


****** Internal Slot: =rank=                                                     :slot:

- Value type: =fixnum=
- Initial value: =-1=
- Initargs: none
- Allocation: instance


******* Description

Rank in priority queue - used internally for
         efficient removal from queue.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target: <<class transmission-channel>>


**** External Class: =transmission-channel=                                   :class:


***** Inheritance

- Parent classes:
    [[class channel][channel]]
- Precedence list:
    [[class transmission-channel][transmission-channel]], [[class
    channel][channel]], [[class component][component]], [[class parameter
    object][parameter-object]], [[class entity-with-signals][entity-with-signals]],
    [[class owned-object][owned-object]], [[class named-object][named-object]],
    [[class lens-object][lens-object]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Parameters



***** Description

Base classe for all transmission channels


***** Direct Slots



***** Indirect Slots

# link target 2: <<source-gate>>
# link target: <<slot source-gate>>


****** Internal Slot: =source-gate=                                              :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: source-gate
- Allocation: instance


******* Description

The gate which sends messages over the channel.


# link target 2: <<initialized-p>>
# link target: <<slot initialized-p>>


****** External Slot: =initialized-p=                                            :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

True if this component has been initialized.


# link target 2: <<rng-map>>
# link target: <<slot rng-map>>


****** External Slot: =rng-map=                                                  :slot:

- Value type: =array=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

RNG map for this component


# link target 2: <<collect-trace-info>>
# link target: <<slot collect-trace-info>>


****** Internal Slot: =collect-trace-info=                                       :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

If true tracelog outputs will be traced for this component.


# link target 2: <<properties>>
# link target: <<slot properties>>


****** Internal Slot: =properties=                                               :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: properties
- Allocation: instance


******* Description

Per instance property list


# link target 2: <<has-ancestor-listeners>>
# link target: <<slot has-ancestor-listeners>>


****** Internal Slot: =has-ancestor-listeners=                                   :slot:

- Value type: =simple-bit-vector=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have ancestor
    listeners.


# link target 2: <<has-local-listeners>>
# link target: <<slot has-local-listeners>>


****** Internal Slot: =has-local-listeners=                                      :slot:

- Value type: =simple-bit-vector=
- Initial value: =(MAKE-ARRAY +SIGNAL-CACHE-SIZE+ :ELEMENT-TYPE 'BIT           
                   :INITIAL-ELEMENT 0)=
- Initargs: none
- Allocation: instance


******* Description

A bit map recording which signals have local listeners.


# link target 2: <<signal-table>>
# link target: <<slot signal-table>>


****** Internal Slot: =signal-table=                                             :slot:

- Value type: =hash-table=
- Initial value: =(MAKE-HASH-TABLE)=
- Initargs: none
- Allocation: instance


******* Description

Hash by signal of lists of registered listeners
    for this entity.


# link target 2: <<owner>>
# link target: <<slot owner>>


****** External Slot: =owner=                                                    :slot:

- Value type: =named-object=
- Initial value: =NIL=
- Initargs: owner
- Allocation: instance


******* Description

Object which owns this in object heirarchy


# link target 2: <<index>>
# link target: <<slot index>>


****** External Slot: =index=                                                    :slot:

- Value type: =fixnum=
- Initial value: =NIL=
- Initargs: index
- Allocation: instance


******* Description

Position in an object vector (if it is in an
          object array)


# link target 2: <<name>>
# link target: <<slot name>>


****** External Slot: =name=                                                     :slot:

- Value type: =symbol=
- Initial value: =NIL=
- Initargs: name
- Allocation: instance


******* Description

Name of this object - used when addressing
         the object internally or through simulation paramaters.





-----

# link target 2: <<unknown-message>>
# link target: <<class unknown-message>>


**** External Class: =unknown-message=                                        :class:


***** Inheritance

- Parent classes:
    [[class warning][warning]]
- Precedence list:
    [[class unknown-message][unknown-message]], [[class warning][warning]], [[class
    condition][condition]], [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Not documented.


***** Direct Slots

# link target: <<slot module>>


****** External Slot: =module=                                                   :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: module
- Allocation: instance


******* Accessors

-----

# link target: <<slot-accessor module>>


******** External Slot Accessor: =module=                                 :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(module condition)
#+END_SRC


********* Methods

- (=module= (condition [[class unknown-message][=unknown-message=]]))





# link target: <<slot message>>


****** External Slot: =message=                                                  :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: message
- Allocation: instance


******* Accessors

-----

# link target: <<slot-accessor message>>


******** External Slot Accessor: =message=                                :reader:writer:


********* Syntax

#+BEGIN_SRC lisp
(message condition)
#+END_SRC


********* Methods

- (=message= (condition [[class unknown-message][=unknown-message=]]))








-----

# link target 2: <<with-timers>>
# link target: <<class with-timers>>


**** External Class: =with-timers=                                            :class:


***** Inheritance

- Parent classes:
    [[class standard-object][standard-object]]
- Precedence list:
    [[class with-timers][with-timers]], [[class standard-object][standard-object]],
    [[class slot-object][slot-object]], [[class t][t]]
- Direct subclasses:
    None.


***** Description

Mixin class with dynamic timer handling. See
  [[set-timer]], [[handle-timer]] and [[cancel-timer]] for additional
  functionality provided for this class.


***** Direct Slots

# link target 2: <<timers>>
# link target: <<slot timers>>


****** Internal Slot: =timers=                                                   :slot:

- Value type: =list=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


******* Description

Active Timers which aren't cached in slots







*** External Structures

-----

# link target 2: <<channel-result>>
# link target: <<structure channel-result>>


**** External Structure: =channel-result=                                 :structure:

***** Slots

- delay :: The propagation delay of the channel
- duration :: The transmition duration of the packet.
- discard :: If true packet packet will be discarded (was lost in transmission)

***** Description

Structure containg result of process-message from a channel

***** Slots

# link target 2: <<delay>>
# link target: <<slot delay>>


****** External Slot: =delay=                                                    :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: none
- Allocation: instance


# link target 2: <<duration>>
# link target: <<slot duration>>


****** External Slot: =duration=                                                 :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: none
- Allocation: instance


# link target 2: <<discard>>
# link target: <<slot discard>>


****** Internal Slot: =discard=                                                  :slot:

- Value type: =boolean=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance





-----

# link target 2: <<coord>>
# link target: <<structure coord>>


**** External Structure: =coord=                                          :structure:


***** Description

A spatial coordinate


***** Slots

# link target 2: <<x>>
# link target: <<slot x>>


****** Internal Slot: =x=                                                        :slot:

- Value type: =float=
- Initial value: =0.0=
- Initargs: none
- Allocation: instance


# link target 2: <<y>>
# link target: <<slot y>>


****** Internal Slot: =y=                                                        :slot:

- Value type: =float=
- Initial value: =0.0=
- Initargs: none
- Allocation: instance


# link target 2: <<z>>
# link target: <<slot z>>


****** Internal Slot: =z=                                                        :slot:

- Value type: =float=
- Initial value: =0.0=
- Initargs: none
- Allocation: instance





-----

# link target 2: <<message-sent-signal-value>>
# link target: <<structure message-sent-signal-value>>


**** External Structure: =message-sent-signal-value=                      :structure:

***** Slots

- timestamp :: a [[time-type]] - the time message was sent
- message :: a [[message]] being sent.
- result :: a [[channel-result]]

***** Description


Structure used to to pass information on =message-sent= signal
conataining the time it was sent, the message and the channel result.

***** Slots

# link target 2: <<timestamp>>
# link target: <<slot timestamp>>


****** External Slot: =timestamp=                                                :slot:

- Value type: =time-type=
- Initial value: =(SIMULATION-TIME)=
- Initargs: none
- Allocation: instance


# link target: <<slot message>>


****** External Slot: =message=                                                  :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance


# link target 2: <<result>>
# link target: <<slot result>>


****** Internal Slot: =result=                                                   :slot:

- Value type: =channel-result=
- Initial value: =(MAKE-CHANNEL-RESULT)=
- Initargs: none
- Allocation: instance





-----

# link target 2: <<timestamped>>
# link target: <<structure timestamped>>


**** External Structure: =timestamped=                                    :structure:

***** Slots


- time :: a /time-type/ (default [[simulation-time]])
- value :: a value

***** Description


Structure associating a time with a value.

***** Slots

# link target 2: <<time>>
# link target: <<slot time>>


****** Inherited Slot: =time=                                                    :slot:

- Value type: =time-type=
- Initial value: =(SIMULATION-TIME)=
- Initargs: none
- Allocation: instance


# link target 2: <<value>>
# link target: <<slot value>>


****** Internal Slot: =value=                                                    :slot:

- Value type: =t=
- Initial value: =NIL=
- Initargs: none
- Allocation: instance





-----

# link target 2: <<timestamped-queue>>
# link target: <<structure timestamped-queue>>


**** External Structure: =timestamped-queue=                              :structure:


***** Description

A timestamped queue records the simulation time of when items are
enqueued.  [[dequeue]] and [[peek]] from a [[timestamped-queue]]
returns this time as a second value. The timestamped-queue also keeps
track of the average queue duration which can be obtained using
[[average-queue-time]].


***** Slots

# link target 2: <<average-timestamp>>
# link target: <<slot average-timestamp>>


****** Internal Slot: =average-timestamp=                                        :slot:

- Value type: =time-type=
- Initial value: =0.0d0=
- Initargs: none
- Allocation: instance







*** External Types

-----

# link target: <<type gate-direction>>


**** External Type: =gate-direction=                                           :type:

Not documented.


-----

# link target 2: <<time-type>>
# link target: <<type time-type>>


**** External Type: =time-type=                                                :type:

Not documented.




*** External Constants

-----

# link target 2: <<..2b..c..2b..>>
# link target: <<constant ..2b..c..2b..>>


**** External Constant: =+c+=                                              :constant:


***** Value

: 2.99792458d8

Type: =double-float=


***** Description

Speed of Light in m/sec





*** External Global Variables

-----

# link target 2: <<*context*>>
# link target: <<variable *context*>>


**** External Variable: =*context*=                                        :variable:


***** Value

: NIL

Type: =null=


***** Description

Current global component context in which evaluation is taking
  place. It is used to determine mapping for random number streams and
  for providing tracing context. This should be bound for the extent
  of exposed interfaces to components. The kernel binds it around
  the [[handle-message]] and [[initialize]] methods. 



-----

# link target 2: <<*simulation*>>
# link target: <<variable *simulation*>>


**** External Variable: =*simulation*=                                     :variable:


***** Value

: NIL

Type: =null=


***** Description

The global [[simulation]] instance



-----

# link target 2: <<*simulation-init-hooks*>>
# link target: <<variable *simulation-init-hooks*>>


**** External Variable: =*simulation-init-hooks*=                          :variable:


***** Value

: (ADD-STATISTICS)

Type: =cons=


***** Description

A list of functions which take the simulation as an argument which
  are called after simulation etc is created. Can be used to add in
  layers which use signals such as statistical reporting or graphical
  presentation.



-----

# link target 2: <<*simulation-trace-stream*>>
# link target: <<variable *simulation-trace-stream*>>


**** External Variable: =*simulation-trace-stream*=                        :variable:


***** Value

: #<SWANK-BACKEND::SLIME-OUTPUT-STREAM {BC4F6C1}>

Type: =slime-output-stream=


***** Description

The stream on which tracing information (using [[tracelog]]) is to be written.



-----

# link target 2: <<*time-format*>>
# link target: <<variable *time-format*>>


**** External Variable: =*time-format*=                                    :variable:


***** Value

: "~7/lens::sec/"

Type: =simple-array=


***** Description

The time format control used
when tracing.



-----

# link target: <<variable network>>


**** External Variable: =network=                                          :variable:


***** Value

: NIL

Type: =null=


***** Description

Network name for current run





*** External Macros

-----

# link target 2: <<define-statistic-filter>>
# link target: <<macro define-statistic-filter>>


**** External Macro: =define-statistic-filter=                                :macro:


***** Syntax

#+BEGIN_SRC lisp
(define-statistic-filter name
    (var &rest statevars)
  &body
  body)
#+END_SRC

***** Arguments


- name :: a =symbol= (evaluated)
- var :: a =symbol= (evaluated)
- statevars :: a binding form*
- body :: form*

***** Description


Define and register a statistic filter function. /var/ is the name
used in /body/ to refer to the input value. statevars are the state
value definitions as per let which are bound outside the
finction. /body/ must return the filter value or null to abort
filtering.

***** Example


#+BEGIN_SRC lisp
 (define-statistic-filter count(value (count 0))
   (declare (ignore value))
   (incf count))
#+END_SRC



-----

# link target 2: <<filter>>
# link target: <<macro filter>>


**** External Macro: =filter=                                                 :macro:


***** Syntax

#+BEGIN_SRC lisp
(filter test lst &key (key '#'identity))
#+END_SRC

***** Arguments

- test :: a designator for a function of one argument which returns a
          generalised boolean
- lst :: a proper list
- key :: a designator for a function of one argument

***** Returns


- result :: a list

***** Description

Return a list of the elements in =lst= for which =test= (applied to =key=)
is true.


-----

# link target 2: <<for>>
# link target: <<macro for>>


**** External Macro: =for=                                                    :macro:


***** Syntax

#+BEGIN_SRC lisp
(for (var start stop)
  &body
  body)
#+END_SRC

***** Arguments

- var ::  a variable name (not evaluated)
- start :: an integer (evaluated)
- stop :: an integer (evaluated)
- body :: a list of +forms+

***** Description


Iterate from the value supplied by =start= upto but not including the
value supplied by =end= setting =var= to each value in turn before
evaluating the +body+


-----

# link target 2: <<tracelog>>
# link target: <<macro tracelog>>


**** External Macro: =tracelog=                                               :macro:


***** Syntax

#+BEGIN_SRC lisp
(tracelog &rest args)
#+END_SRC

***** Rest Arguments


- args :: list of format arguments.

***** Description


Write to [[*simulation-trace-stream*]] using /args/ provided the
[[collect-trace-info]] parameter for the current [[*context*]] is true.

This is designed to enable efficient configuration file controlled
tracing of simulation execution.


-----

# link target 2: <<until>>
# link target: <<macro until>>


**** External Macro: =until=                                                  :macro:


***** Syntax

#+BEGIN_SRC lisp
(until test
  &body
  body)
#+END_SRC


***** Description

Repeat body until test returns true



-----

# link target 2: <<while>>
# link target: <<macro while>>


**** External Macro: =while=                                                  :macro:


***** Syntax

#+BEGIN_SRC lisp
(while test
  &body
  body)
#+END_SRC


***** Description

A while loop - repeat body while test is true





*** External Functions

-----

# link target 2: <<..3c....3d..>>
# link target: <<function ..3c....3d..>>


**** External Function: =<==                                               :function:


***** Syntax

#+BEGIN_SRC lisp
(<= number &rest more-numbers)
#+END_SRC


***** Description

Return T if arguments are in strictly non-decreasing order, NIL otherwise.



-----

# link target 2: <<..3c....3d..>>
# link target: <<function ..3c....3d..>>


**** External Function: =<==                                               :function:


***** Syntax

#+BEGIN_SRC lisp
(<= number &rest more-numbers)
#+END_SRC


***** Description

Return T if arguments are in strictly non-decreasing order, NIL otherwise.



-----

# link target 2: <<arrival-time>>
# link target: <<function arrival-time>>


**** External Function: =arrival-time=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(arrival-time event)
#+END_SRC


***** Description

Return the simulation time at which an event is to be handled



-----

# link target 2: <<arrived>>
# link target: <<function arrived>>


**** External Function: =arrived=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(arrived module message gate arrival-time)
#+END_SRC

***** Arguments


- module :: a [[module]]
- message :: a [[message]]
- gate :: a [[gate]]
- arrival-time :: a [[time-type]]

*Description

Called when the /message/ arrives at the /gate/ which is not further
connected (that is, next-gate is NULL) of of /module/. /arrival-time/
is when the message is to be delivered.

The default implementation will fill in the arrival gate details in the /message/ and schedule it for delivery at the /arrival-time/. Packets will be schedule at the /arrival-time/ + their [[duration]] unless [[deliver-on-reception-start-p]] is set true for the gate in which case they will the [[reception-start-p]] will be set true for the packet and they will be delivered at /arrival-time/.


-----

# link target 2: <<average-queue-time>>
# link target: <<function average-queue-time>>


**** External Function: =average-queue-time=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(average-queue-time queue)
#+END_SRC

***** Arguments


- queue :: a [[timestamped-queue]]

***** Description


Returns the average simulation time items have been on /queue/.


-----

# link target 2: <<bernoulli>>
# link target: <<function bernoulli>>


**** External Function: =bernoulli=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(bernoulli p &optional (rng 0))
#+END_SRC

***** Arguments


- p :: an =integer=

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Returns the result of a Bernoulli trial with probability /p/,
 that is, 1 with probability /p/ and 0 with probability /(1-p)/ using the random number stream /rng/  in the current context.


-----

# link target 2: <<beta>>
# link target: <<function beta>>


**** External Function: =beta=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(beta alpha1 alpha2 &optional (rng 0))
#+END_SRC

***** Arguments


- alpha1 :: a positive =real= number
- alpha2 ::  a positive =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the beta distribution with parameters
 /alpha1/, /alpha2/ from the random number stream /rng/ in the current
context.

Generation is using relationship to Gamma distribution (see
[[gamma-d]]): if /Y1/ has gamma distribution with /alpha=alpha1/ and /beta=1/
and /Y2/ has gamma distribution with /alpha=alpha2/ and /beta=2/, then /Y =
Y1/(Y1+Y2)/ has beta distribution with parameters /alpha1/ and /alpha2/.


-----

# link target 2: <<binomial>>
# link target: <<function binomial>>


**** External Function: =binomial=                                         :function:


***** Syntax

#+BEGIN_SRC lisp
(binomial n p &optional (rng 0))
#+END_SRC

***** Arguments


- n :: an =integer= /n>0/
- p :: an =integer= /0<=p<=1/

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Return a random integer from the binomial distribution with
parameters /n/ and /p/, that is, the number of successes in /n/ independent
trials with probability /p/ using the random number stream /rng/ in the current
context.

Generation is using the relationship to Bernoulli
distribution (runtime is proportional to /n/).


-----

# link target 2: <<bit-error-p>>
# link target: <<function bit-error-p>>


**** External Function: =bit-error-p=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(bit-error-p object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<bit-length>>
# link target: <<function bit-length>>


**** External Function: =bit-length=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(bit-length entity)
#+END_SRC


***** Description

Return the length in bits of an =entity=. This is
  the [[byte-length]] * 8 for most entities, but is the actual length
  of a =bit-vector= which may be used to represent bit fields.



-----

# link target 2: <<buffer-size>>
# link target: <<function buffer-size>>


**** External Function: =buffer-size=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(buffer-size object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<buffer-size-bytes>>
# link target: <<function buffer-size-bytes>>


**** External Function: =buffer-size-bytes=                                :function:


***** Syntax

#+BEGIN_SRC lisp
(buffer-size-bytes object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<build-connections>>
# link target: <<function build-connections>>


**** External Function: =build-connections=                                :function:


***** Syntax

#+BEGIN_SRC lisp
(build-connections module)
#+END_SRC

***** Arguments


- module :: a [[compound-module]]

***** Description


Build connections between submodules and gates of /module/ as per the
=:connections=. This may be specialised usefully to add in build the
network connections algorithmically.


-----

# link target 2: <<build-gates>>
# link target: <<function build-gates>>


**** External Function: =build-gates=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(build-gates module)
#+END_SRC

***** Arguments


- module :: a [[module]]

***** Description


Build the module gates on the basis of the gate specification from the
=:gates= argument in the [[module-class]] specification.

This method is called during a [[module]] instance initialisation.


-----

# link target 2: <<build-inside>>
# link target: <<function build-inside>>


**** External Function: =build-inside=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(build-inside module)
#+END_SRC

***** Arguments


- module :: a [[module]]

***** Description


Build the the submodules (calling [[build-submodules]]) of
[[compound-module]] /module/ as per the =:submodules= class argument and
connect them (calling [[build-connections]] as per the
=:connections= class argument.

This method is recursively called upon [[network]] creation.


-----

# link target 2: <<build-submodules>>
# link target: <<function build-submodules>>


**** External Function: =build-submodules=                                 :function:


***** Syntax

#+BEGIN_SRC lisp
(build-submodules module)
#+END_SRC

***** Arguments


- module :: a [[compound-module]]

***** Description


Build the submodules inside a [[compound-module]]
as per the =:submodules= class argument. This may be specialised
usefully to add in additional submodule creation algoritmically.


-----

# link target 2: <<busy-p>>
# link target: <<function busy-p>>


**** External Function: =busy-p=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(busy-p channel)
#+END_SRC

***** Arguments

- channel :: a [[transmission-channel]]

***** Returns

- busy :: a =boolean=

***** Description


For transmission channels: returns whether the sender gate
is currently transmitting, ie. whether [[transmission-finish-time]]
is greater than the current simulation time.


-----

# link target 2: <<byte-length>>
# link target: <<function byte-length>>


**** External Function: =byte-length=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(byte-length entity)
#+END_SRC


***** Description

Return the length in whole octets (8 bit bytes) of
  an =entity=. For a [[packet]] the length should include the length
  of all encapsulated packets together with its overhead.



-----

# link target 2: <<calculate-duration>>
# link target: <<function calculate-duration>>


**** External Function: =calculate-duration=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(calculate-duration channel message)
#+END_SRC

***** Arguments

- channel :: a [[transmission-channel]]
- message :: a [[message]]

***** Returns

- duration :: a [[time-type]]

***** Description


Calculates the transmission duration of the message with the current
transmission channel configuration (datarate, etc); it does not check
or modify channel state. For non-transmission channels this method
returns zero.

This method is useful for transmitter modules that need to determine
the transmission time of a packet without actually sending the packet.

Caveats: this method is best-effort -- there is no guarantee that
transmission time when the packet is actually sent will be the same as
the value returned by this method. The difference may be caused by
changed channel parameters (i.e. datarate being overwritten), or by a
non-time-invariant transmission algorithm.

Note that there is no requirement that [[method process-message]]
relies on this method to calculated the packet duration. That is, to
change the duration computation algorithm via subclassing you need to
redefine *both* [[process-message]] and [[calculate-duration]].


-----

# link target 2: <<cancel>>
# link target: <<function cancel>>


**** External Function: =cancel=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(cancel event)
#+END_SRC

***** Arguments


- event :: an [[event]]

***** Description


Cancel event /event/ if it was scheduled.


-----

# link target 2: <<cancel-timer>>
# link target: <<function cancel-timer>>


**** External Function: =cancel-timer=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(cancel-timer module timer)
#+END_SRC

***** Arguments


- module :: an instance of [[with-timers]]
- timer :: a timer designator (either =symbol= or [[timer-message]])

***** Description


Cancel an already schedule timer designated by /timer/ associated with
/module/.  If the associated [[timer-message]] was created when
scheduled [[set-timer]] it will be deleted at this point.


-----

# link target 2: <<cauchy>>
# link target: <<function cauchy>>


**** External Function: =cauchy=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(cauchy a b &optional (rng 0))
#+END_SRC

***** Arguments


- a :: a /real/
- b :: a positive /real/

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the Cauchy distribution (also called
Lorentzian distribution) with parameters a,b where b>0 using the
random number stream /rng/ in the current context.

This is a continuous distribution describing resonance behavior.
It also describes the distribution of horizontal distances at which
a line segment tilted at a random angle cuts the x-axis.

Generation uses the inverse transform.


-----

# link target: <<function channel>>


**** External Function: =channel=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(channel object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<chi-square>>
# link target: <<function chi-square>>


**** External Function: =chi-square=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(chi-square k &optional (rng 0))
#+END_SRC

***** Arguments


- k :: a positive integer

***** Optional Arguments


- rng :: an =integer= (default 0)

Returns a random variate from the chi-square distribution with /k/
degrees of freedom using the random number stream /rng/ in the current
context.

The chi-square distribution arises in statistics. If Y_i are /k/
independent random variates from the normal distribution with unit
variance, then the sum-of-squares (sum(Y_i^2)) has a chi-square
distribution with /k/ degrees of freedom.

The expected value of this distribution is /k/. Chi_square with
parameter /k/ is gamma-distributed with /alpha/=/k//2, /beta/=2.

Generation is using relationship to gamma distribution (see [[gamma-d]]).


-----

# link target 2: <<configuration>>
# link target: <<function configuration>>


**** External Function: =configuration=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(configuration instance)
#+END_SRC


***** Description

Return the configuration trie with an instance. By
  default this will be the configuration read at the start of the
  simulation.



-----

# link target 2: <<configure>>
# link target: <<function configure>>


**** External Function: =configure=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(configure instance)
#+END_SRC


***** Description

Configure an instances unbound parameter slots from
  configuration data. Called after initialization from initargs but
  before initialization from initforms (defaults)



-----

# link target 2: <<connect>>
# link target: <<function connect>>


**** External Function: =connect=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(connect from-gate to-gate &key channel leave-uninitialized)
#+END_SRC


***** Description

Connects the gate to another gate, using the given
channel object (if one is specified). This method can be used to
manually create connections for dynamically created modules.

This method invokes [[initialize]] on the channel object, unless the
compound module containing this connection is not yet
initialized (then it assumes that this channel will be initialized as
part of the compound module initialization process.) To leave the
channel uninitialized, specify true for the leave-uninitialized
parameter.

If the gate is already connected, an error will occur. The gate
argument cannot be nil, that is, you cannot use this function
to disconnect a gate; use [[disconnect]] for that.

***** Simulation Events


- pre-model-change :: a =list=. Emitted before the gate is connected
- post-model-change :: a =list=. Emitted after the gate is connected.

Model change events are emiited with a list describing the
change. This list has a descriptive symbol followed by keyword
arguments of the elements involved in the change. [[connect]] provides
the following model change notifications.

- gate-connect-notification :: signalled in the module containing this gate
- path-create-notification :: signalled to the start and end modules of path



-----

# link target 2: <<connected-outside-p>>
# link target: <<function connected-outside-p>>


**** External Function: =connected-outside-p=                              :function:


***** Syntax

#+BEGIN_SRC lisp
(connected-outside-p gate)
#+END_SRC


***** Description

Return true if a gate is connected to the outside of its module.



-----

# link target 2: <<connected-p>>
# link target: <<function connected-p>>


**** External Function: =connected-p=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(connected-p instance)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<control-info>>
# link target: <<function control-info>>


**** External Function: =control-info=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(control-info object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<coord*>>
# link target: <<function coord*>>


**** External Function: =coord*=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(coord* a b)
#+END_SRC


***** Description

Return element wise (scalar) multiplation of [[coord]]s a and b.



-----

# link target 2: <<coord..2b..>>
# link target: <<function coord..2b..>>


**** External Function: =coord+=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(coord+ a b)
#+END_SRC


***** Description

Add two [[coord]]s together returning result [[coord]]



-----

# link target 2: <<coord->>
# link target: <<function coord->>


**** External Function: =coord-=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(coord- a b)
#+END_SRC


***** Description

Return a-b for [[coord]]s



-----

# link target 2: <<coord-op>>
# link target: <<function coord-op>>


**** External Function: =coord-op=                                         :function:


***** Syntax

#+BEGIN_SRC lisp
(coord-op op &rest coords)
#+END_SRC


***** Description

Given a function and a set of coordinates apply op to each set of
ordinates



-----

# link target 2: <<coord-x>>
# link target: <<function coord-x>>


**** External Function: =coord-x=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(coord-x instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<coord-y>>
# link target: <<function coord-y>>


**** External Function: =coord-y=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(coord-y instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<coord-z>>
# link target: <<function coord-z>>


**** External Function: =coord-z=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(coord-z instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<copy-slots>>
# link target: <<function copy-slots>>


**** External Function: =copy-slots=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(copy-slots slots source destination)
#+END_SRC

***** Arguments

- slots :: a list of slot names
- source :: a class instance
- destination :: a class instance

***** Returns

- destination :: a class instance

***** Description

Copies named slot values shallowly from source to destination
returning the modifed destination object.


-----

# link target 2: <<cpu-time-limit>>
# link target: <<function cpu-time-limit>>


**** External Function: =cpu-time-limit=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(cpu-time-limit object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<creation-time>>
# link target: <<function creation-time>>


**** External Function: =creation-time=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(creation-time object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<cumulative-density-function>>
# link target: <<function cumulative-density-function>>


**** External Function: =cumulative-density-function=                      :function:


***** Syntax

#+BEGIN_SRC lisp
(cumulative-density-function instance x)
#+END_SRC


***** Description

Returns the estimated value of the Cumulated
  Density Function at a given x.



-----

# link target 2: <<decapsulate>>
# link target: <<function decapsulate>>


**** External Function: =decapsulate=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(decapsulate packet)
#+END_SRC


***** Description

Protocols *must* use this to get the encapsulated packet. It returns a duplicate ensuring the returned packet is unique and can be modified.
  Thus it is not necessary to deep copy the encapsulated packets as packets traverse a network.



-----

# link target 2: <<define-result-recorder>>
# link target: <<function define-result-recorder>>


**** External Function: =define-result-recorder=                           :function:


***** Syntax

#+BEGIN_SRC lisp
(define-result-recorder classname &optional (name classname))
#+END_SRC

***** Arguments


- classname :: a =symbol=
- name :: a =symbol=

***** Description


Register the class denoted by /classname/ as a result recorder which
can be denoted by name /name/ in configuration files and =:statistic=
propery definitons of simulation components.


-----

# link target 2: <<delay>>
# link target: <<function delay>>


**** External Function: =delay=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(delay object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<deliver>>
# link target: <<function deliver>>


**** External Function: =deliver=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(deliver message gate time)
#+END_SRC


***** Description

This function is called internally by the [[send]]
  functions and channel classes' [[deliver]] to deliver the message to
  its destination.



-----

# link target 2: <<deliver-on-reception-start-p>>
# link target: <<function deliver-on-reception-start-p>>


**** External Function: =deliver-on-reception-start-p=                     :function:


***** Syntax

#+BEGIN_SRC lisp
(deliver-on-reception-start-p object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<dequeue>>
# link target: <<function dequeue>>


**** External Function: =dequeue=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(dequeue q)
#+END_SRC


***** Description

Return next element x from queue q



-----

# link target 2: <<detailed-info>>
# link target: <<function detailed-info>>


**** External Function: =detailed-info=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(detailed-info o)
#+END_SRC


***** Description

Return detailed, multi-line, arbitrarily long
description of the object. The string appears in the graphical
user interface (Tkenv) together with other object data (e.g. class name)
wherever it is feasible to display a multi-line string.



-----

# link target 2: <<disabled-p>>
# link target: <<function disabled-p>>


**** External Function: =disabled-p=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(disabled-p object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<disconnect>>
# link target: <<function disconnect>>


**** External Function: =disconnect=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(disconnect gate)
#+END_SRC


***** Description

Disconnects the gate, and also deletes the
  associated channel object if one has been set. disconnect() must be
  invoked on the source gate (from side) of the connection.  The
  method has no effect if the gate is not connected.

***** Simulation Events


- pre-model-change :: a =list=. Emitted before the gate is disconnected
- post-model-change :: a =list=. Emitted after the gate is disconnected.

Model change events are emiited with a list describing the
change. This list has a descriptive symbol followed by keyword
arguments of the elements involved in the change. [[disconnect]] provides
the following model change notifications.

- gate-disconnect-notification :: signalled in the module containing this gate
- path-cut-notification :: signalled to the start and end modules of path



-----

# link target 2: <<distance>>
# link target: <<function distance>>


**** External Function: =distance=                                         :function:


***** Syntax

#+BEGIN_SRC lisp
(distance a b)
#+END_SRC


***** Description

Return the Euclidean distance between two entities
  =a= and =b=



-----

# link target 2: <<do-histogram>>
# link target: <<function do-histogram>>


**** External Function: =do-histogram=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(do-histogram values &key (min -1) (max 1) (n 10))
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<duplicate>>
# link target: <<function duplicate>>


**** External Function: =duplicate=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(duplicate object &optional duplicate)
#+END_SRC


***** Description

Should be redefined in subclasses to create an
  exact copy of this object. The default implementation just throws an
  error, to indicate that the method was not redefined. The second
  argument, if defined should be the instance that the object is being
  duplicated into. By default this will be a new instance of the same
  class as the object to be duplicated.

For packets this does a shallow copy i.e. copies fields only and does
not recurse into the encapsulated packets.



-----

# link target 2: <<duplicate-p>>
# link target: <<function duplicate-p>>


**** External Function: =duplicate-p=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(duplicate-p entity buffer &optional record)
#+END_SRC

***** Arguments


- entity :: an object
- buffer :: a [[history-buffer]]

***** Optional Arguments


- record :: a =boolean= (default t)

***** Description


Returns true if the /entity/ is recorded in the /buffer/. If /record/
is true then /entity will be recorded in the buffer.


-----

# link target 2: <<emit>>
# link target: <<function emit>>


**** External Function: =emit=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(emit entity signal &optional value)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: a signal identifier

***** Optional Arguments


- value :: a value

***** Description


Emit the optional /value/ with a signal. If the given signal has
listeners in this component /entity/ or in it's ancestor components,
their appropriate [[receive-signal]] methods get called.


-----

# link target 2: <<empty-p>>
# link target: <<function empty-p>>


**** External Function: =empty-p=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(empty-p s)
#+END_SRC


***** Description

Return true if a data structure is empty



-----

# link target 2: <<encapsulate>>
# link target: <<function encapsulate>>


**** External Function: =encapsulate=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(encapsulate packet packet-to-be-encapsulated)
#+END_SRC


***** Description

Called to encapsulate one packet within another.



-----

# link target 2: <<end-module>>
# link target: <<function end-module>>


**** External Function: =end-module=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(end-module gate)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<enqueue>>
# link target: <<function enqueue>>


**** External Function: =enqueue=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(enqueue x q)
#+END_SRC


***** Description

Add element x to end of queue q



-----

# link target 2: <<erlang-k>>
# link target: <<function erlang-k>>


**** External Function: =erlang-k=                                         :function:


***** Syntax

#+BEGIN_SRC lisp
(erlang-k k m &optional (rng 0))
#+END_SRC

***** Arguments


- k :: a positive integer
- m ::  a positive =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

Returns a random variate from the Erlang distribution with /k/ phases
and mean /m/ using the random number stream /rng/ in the current
context.

This is the sum of /k/ mutually independent random variables, each with
exponential distribution. Thus, the /k/th arrival time in the Poisson
process follows the Erlang distribution.

Erlang with parameters /m/ and /k. is gamma-distributed (see
[[gamma-d]] with /alpha/=/k/ and /beta/=/m/ / /k/.

Generation makes use of the fact that exponential distributions
sum up to Erlang.


-----

# link target 2: <<exponential>>
# link target: <<function exponential>>


**** External Function: =exponential=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(exponential mean &optional (rng 0))
#+END_SRC

***** Arguments


- mean :: a =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate =double float= from the exponential
distribution with the given mean /mean/ (that is, with parameter
lambda=1/mean/) from random number stream /rng/ in the current
context.


-----

# link target 2: <<find-object>>
# link target: <<function find-object>>


**** External Function: =find-object=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(find-object parent name &optional deep)
#+END_SRC


***** Description

Finds the object with the given name. This function
  is useful when called on subclasses that are containers. This method
  finds the object with the given name in a container object and
  returns a pointer to it or NULL if the object has not been found. If
  deep is false, only objects directly contained will be searched,
  otherwise the function searches the whole subtree for the object. It
  uses the [[for-each-child]] mechanism.



-----

# link target 2: <<finish>>
# link target: <<function finish>>


**** External Function: =finish=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(finish component)
#+END_SRC

***** Arguments


- component ::  a simulation [[component]]

***** Description


Called depth first for every /component/ at end of simulation. May bee used to finalise statistics and alalysis summary.


-----

# link target 2: <<for-each-channel>>
# link target: <<function for-each-channel>>


**** External Function: =for-each-channel=                                 :function:


***** Syntax

#+BEGIN_SRC lisp
(for-each-channel module operator)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<for-each-child>>
# link target: <<function for-each-child>>


**** External Function: =for-each-child=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(for-each-child parent operator)
#+END_SRC


***** Description

Enables traversing the object tree, performing some
  operation on each object. Tyhe default [[module]] and
  [[compound-module]] provide implementations that will recurse over
  gates, submodules and channels if stored in the usual
  way. Implementations may wish to overwrite if storing some
  subelements that may be considered as children differently.



-----

# link target 2: <<for-each-gate>>
# link target: <<function for-each-gate>>


**** External Function: =for-each-gate=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(for-each-gate module operator)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<for-each-submodule>>
# link target: <<function for-each-submodule>>


**** External Function: =for-each-submodule=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(for-each-submodule module operator)
#+END_SRC

***** Arguments


- module :: a [[module]]
- operator :: a =function=

***** Description


Applies /operator/ over each submodule of a /module/.

Objects with submodules must provide this to iterate over
submodules. [[module]] and [[compound-module]] classes provide
implementations automatically however if additional submodules
beyond those specified in the class are created it may be necessary
to specialise this function to include them..


-----

# link target 2: <<format-from-type>>
# link target: <<function format-from-type>>


**** External Function: =format-from-type=                                 :function:


***** Syntax

#+BEGIN_SRC lisp
(format-from-type type)
#+END_SRC


***** Description

Given a type declaration return a format declaration suitable for use in [[parse-input]] to covert a parameter string to internal representation.



-----

# link target 2: <<from-gate>>
# link target: <<function from-gate>>


**** External Function: =from-gate=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(from-gate message)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<from-module>>
# link target: <<function from-module>>


**** External Function: =from-module=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(from-module message)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<full-name>>
# link target: <<function full-name>>


**** External Function: =full-name=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(full-name o)
#+END_SRC


***** Description

When this object is part of a vector (like a
submodule can be part of a module vector, or a gate can be part of a
gate vector), this method returns the object's name with the index in
brackets;



-----

# link target 2: <<full-path>>
# link target: <<function full-path>>


**** External Function: =full-path=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(full-path o)
#+END_SRC


***** Description

Returns the full path of the object in the object
hierarchy, like '(net host 2 tcp winsize)'. This path could be used as
an address to locate the object later in the network.

If there is an owner object, this method returns the owner's [[full-path]]
with this object's [[full-name]] appended, otherwise it simply
returns full-name.



-----

# link target 2: <<gamma-d>>
# link target: <<function gamma-d>>


**** External Function: =gamma-d=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(gamma-d alpha theta &optional (rng 0))
#+END_SRC

***** Arguments


- alpha :: a positive =real= number
- theta ::  a positive =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the gamma distribution with parameters
/alpha/>0, /theta/>0 from the random number stream /rng/ in the current
context. /alpha/ is known as the shape parameter, and /theta/
as the scale parameter.

Some sources in the literature use the inverse scale parameter
/beta/ = 1 / /theta/, called the rate parameter. Various other notations
can be found in the literature; our usage of (alpha,theta) is consistent
with Wikipedia and Mathematica (Wolfram Research).

Gamma is the generalization of the Erlang distribution for non-integer
/k/ values, which becomes the alpha parameter. The chi-square distribution
is a special case of the gamma distribution.

For /alpha/=1, Gamma becomes the exponential distribution with /mean/=/theta/.

The mean of this distribution is /alpha*theta/, and variance is /alpha*theta/^2.

Generation: if /alpha/=1, it is generated as [[exponential]](theta).

For alpha>1, we make use of the acceptance-rejection method in
"A Simple Method for Generating Gamma Variables, George Marsaglia and
Wai Wan Tsang", ACM Transactions on Mathematical Software, Vol. 26, No. 3,
September 2000.

The alpha<1 case makes use of the alpha>1 algorithm, as suggested by the
above paper.


-----

# link target: <<function gate>>


**** External Function: =gate=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(gate entity address &key index &allow-other-keys)
#+END_SRC


***** Description

Look up a gate object on entity by address. For a
  module the address will be a list of the gate name, the gate
  direction and if it is a gate array the index of the gate.



-----

# link target: <<function gate-direction>>


**** External Function: =gate-direction=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(gate-direction gate)
#+END_SRC


***** Description

Return the direction of a gate object (either :input or :output).



-----

# link target 2: <<gate-extend>>
# link target: <<function gate-extend>>


**** External Function: =gate-extend=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(gate-extend gate-slot)
#+END_SRC


***** Description

Adds new gate to an gate array returning new gate (or gates if an
inout gate-slot)



-----

# link target 2: <<gate-size>>
# link target: <<function gate-size>>


**** External Function: =gate-size=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(gate-size module name)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<gate-type>>
# link target: <<function gate-type>>


**** External Function: =gate-type=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(gate-type gate-slot)
#+END_SRC


***** Description

Return gate type for a gate slot - :input, :output or :inout



-----

# link target 2: <<geometric>>
# link target: <<function geometric>>


**** External Function: =geometric=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(geometric p &optional (rng 0))
#+END_SRC

***** Arguments


- p :: an =integer= /p>0/

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Returns a random integer from the geometric distribution with parameter /p/.
That is, the number of independent trials with probability /p/ until the
first success. Uses the random number stream /rng/ in the current
context.

This is the /n=1/ special case of the negative binomial distribution.

Generation uses inverse transform.


-----

# link target 2: <<handle-message>>
# link target: <<function handle-message>>


**** External Function: =handle-message=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(handle-message entity message)
#+END_SRC

***** Arguments


-- entity :: a [[module]]
-- message :: a [[message]]

***** Description


[[handle-message]] is the main processing method for
modules and protocols in which they receive messages. It must be
implemented for all simple [[modules]] to implement their
protocols. It may usefully implemented in [[compound-module]]s if they
have input gates not connected to submodules however this is not
normally expected.


-----

# link target 2: <<handle-timer>>
# link target: <<function handle-timer>>


**** External Function: =handle-timer=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(handle-timer module timer-name)
#+END_SRC

***** Arguments


- module :: an instance of [[with-timers]]
- timer-name :: a =symbol=

***** Description


Called when the timer desgnated by /timer-name/ asociated with module
/module/ is fired. Modules will typically should specialise on this
generic function to implment their timer behaviours using the =eql=
specializer form for timer-name.


-----

# link target 2: <<has-listeners>>
# link target: <<function has-listeners>>


**** External Function: =has-listeners=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(has-listeners entity signal)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: =symbol= signal identifier

***** Description


Return true if /entity/ has any listeners for signal designated by
/signal-id/.

For some signals this method has a significant overhead (linear to the
number of hierarchy levels in the network). [[may-have-listeners]] may
be more appropriate in most cases.


-----

# link target 2: <<index>>
# link target: <<function index>>


**** External Function: =index=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(index object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<info>>
# link target: <<function info>>


**** External Function: =info=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(info o)
#+END_SRC


***** Description

Produce a one-line description of object.
The string appears in the graphical user interface (Tkenv) e.g. when
the object is displayed in a listbox. The returned string should
possibly be at most 80-100 characters long, and must not contain
newline.



-----

# link target 2: <<initialize>>
# link target: <<function initialize>>


**** External Function: =initialize=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(initialize component &optional stage)
#+END_SRC

***** Arguments


- component :: a simulation [[component]]
- stage :: a positive =integer=

***** Return


- finished :: a boolean

***** Description


This method is called for every comonent in the simulation after the
whole simulation is created but before the first event is executed. It
allows depth-first staged initialization and configuration for
components which may depend on other components having being
created. It will be called multiple times with /stage/ increasing by
1 (from an initial value of 0) every time until it returns /finished/
as true. This allows for multiple stage initialisation between
codependent object types. Implementations should therefore check the
/stage/ value to insure they don't initialise more than once. An
object is only deemed to be initialised once it [[initialize]] method
and the [[intialize]] method of all subcomponents return true.

list method combination is used so that when subclassing all the
relevant [[initialize]] methods must return true for the effective
method to return true.


-----

# link target 2: <<initialized-p>>
# link target: <<function initialized-p>>


**** External Function: =initialized-p=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(initialized-p component)
#+END_SRC

***** Arguments


- component ::  a simulation [[component]]

***** Description


Returns true if an entity has finished its initialization using the
[[initialize]] method.


-----

# link target 2: <<input>>
# link target: <<function input>>


**** External Function: =input=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(input object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<intuniform>>
# link target: <<function intuniform>>


**** External Function: =intuniform=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(intuniform a b &optional (rng 0))
#+END_SRC

***** Arguments


- a :: an =integer=
- b :: an =integer=

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Returns a random integer /x/ with uniform distribution in the range /a<=x<=b/
 using the random number stream /rng/ in the current
context.


-----

# link target 2: <<latency>>
# link target: <<function latency>>


**** External Function: =latency=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(latency entity)
#+END_SRC

***** Arguments


- entity :: an object

***** Description


Return the latency of the packet or timestampted /entity/ - the time
difference between current [[simulation-time]] and the time the
/rntity/ was timestamped.


-----

# link target 2: <<listeners>>
# link target: <<function listeners>>


**** External Function: =listeners=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(listeners entity signal)
#+END_SRC

***** Arguments


- entity :: a [[entity-with-signals]]
- signal :: a =symbol= or =t=

***** Description


Return list of local listeners to signal denoted by /signal/ for /entity/.
If /signal/ is t return all listeners in /entity/.


-----

# link target 2: <<lognormal>>
# link target: <<function lognormal>>


**** External Function: =lognormal=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(lognormal m w &optional (rng 0))
#+END_SRC

***** Arguments


- m :: a =real= number
- w ::  a =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the lognormal distribution with scale
parameter /m/ and shape parameter /w/ from the random number stream
/rng/ in the current context. /m/ and /w/ correspond to the parameters
of the underlying [[normal]] distribution (/m/: mean,/w/: standard
deviation.)


-----

# link target 2: <<make-coord>>
# link target: <<function make-coord>>


**** External Function: =make-coord=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(make-coord &optional (x 0.0) (y 0.0) (z 0.0))
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<may-have-listeners>>
# link target: <<function may-have-listeners>>


**** External Function: =may-have-listeners=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(may-have-listeners entity signal-id)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: a positive =integer= or =symbol= signal identifier

***** Description


Return true if /entity/ may have listeners for signal
/signal-id/. That is if the corresponding signal has local or ancestor
listeners according to the /entity/ cache/ or the signal is outside
the cache range.

It is intented that this is an efficient check that may be used to
eliminate uneccessary calculations of values and calls to [[emit]].


-----

# link target: <<function message>>


**** External Function: =message=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(message condition)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<message-sent-signal-value-message>>
# link target: <<function message-sent-signal-value-message>>


**** External Function: =message-sent-signal-value-message=                :function:


***** Syntax

#+BEGIN_SRC lisp
(message-sent-signal-value-message instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<message-sent-signal-value-result>>
# link target: <<function message-sent-signal-value-result>>


**** External Function: =message-sent-signal-value-result=                 :function:


***** Syntax

#+BEGIN_SRC lisp
(message-sent-signal-value-result instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<message-sent-signal-value-timestamp>>
# link target: <<function message-sent-signal-value-timestamp>>


**** External Function: =message-sent-signal-value-timestamp=              :function:


***** Syntax

#+BEGIN_SRC lisp
(message-sent-signal-value-timestamp instance)
#+END_SRC


***** Description

Not documented.



-----

# link target: <<function module>>


**** External Function: =module=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(module condition)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<name>>
# link target: <<function name>>


**** External Function: =name=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(name object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<negbinomial>>
# link target: <<function negbinomial>>


**** External Function: =negbinomial=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(negbinomial n p &optional (rng 0))
#+END_SRC

***** Arguments


- n :: an =integer= /n>0/
- p :: an =integer= /0<=p<=1/

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Returns a random integer from the negative binomial distribution with
parameters /n/ and /p/, that is, the number of failures occurring
before /n/ successes in independent trials with probability /p/ of
success.  Uses the random number stream /rng/ in the current context.

Generation is using the relationship to geometric distribution (runtime is
proportional to /n/).


-----

# link target: <<function network>>


**** External Function: =network=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(network object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<nominal-datarate>>
# link target: <<function nominal-datarate>>


**** External Function: =nominal-datarate=                                 :function:


***** Syntax

#+BEGIN_SRC lisp
(nominal-datarate channel)
#+END_SRC

***** Arguments

- channel :: a [[class transmission-channel]]

***** Returns

- nominal-datarate :: a =number=, bits per second

***** Description


Returns the nominal data rate of the channel in bits per
second (bps). The number returned from this method should be treated
as informative; there is no strict requirement that the channel
calculates packet duration by dividing the packet length by the
nominal data rate. For example, specialized channels may add the
length of a lead-in signal to the duration.


-----

# link target 2: <<normal>>
# link target: <<function normal>>


**** External Function: =normal=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(normal &optional (mean 0.0d0) (stddev 1.0d0) (rng 0))
#+END_SRC

***** Optional Arguments


- mean :: a =real= number (default 0)
- stddev ::  a =real= number (default 1d0)
- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the normal distribution with the given
 mean /mean/ and standard deviation /stddev/ from the random number stream
 /rng/ in the current context.


-----

# link target 2: <<output>>
# link target: <<function output>>


**** External Function: =output=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(output object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<owner>>
# link target: <<function owner>>


**** External Function: =owner=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(owner object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<parent-module>>
# link target: <<function parent-module>>


**** External Function: =parent-module=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(parent-module object)
#+END_SRC


***** Description

Return the parent module of this object - not always owner



-----

# link target 2: <<pareto-shifted>>
# link target: <<function pareto-shifted>>


**** External Function: =pareto-shifted=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(pareto-shifted a b c &optional (rng 0))
#+END_SRC

***** Arguments


- a :: a /real/
- b :: a /real/
- c :: a /real/

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the shifted generalized Pareto distribution.

 Generation uses inverse transform.


-----

# link target 2: <<path-end-gate>>
# link target: <<function path-end-gate>>


**** External Function: =path-end-gate=                                    :function:


***** Syntax

#+BEGIN_SRC lisp
(path-end-gate gate)
#+END_SRC


***** Description

Return the last gate in the sequence of gates connected to a gate



-----

# link target 2: <<path-start-gate>>
# link target: <<function path-start-gate>>


**** External Function: =path-start-gate=                                  :function:


***** Syntax

#+BEGIN_SRC lisp
(path-start-gate gate)
#+END_SRC


***** Description

Return the first gate in the sequence of gates connected to a gate



-----

# link target 2: <<peek>>
# link target: <<function peek>>


**** External Function: =peek=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(peek s)
#+END_SRC


***** Description

Return value of next element on set s without
  removing it.



-----

# link target 2: <<poisson>>
# link target: <<function poisson>>


**** External Function: =poisson=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(poisson lambda &optional (rng 0))
#+END_SRC

***** Arguments


- lambda :: an =integer= /lambda>0/

***** Optional Arguments


- rng :: an =integer=  (default 0)

***** Description


Returns a random integer from the Poisson distribution with parameter /lambda/,
that is, the number of arrivals over unit time where the time between
successive arrivals follow exponential distribution with parameter
/lambda/.   Uses the random number stream /rng/ in the current context.

/lambda/ is also the mean (and variance) of the distribution.

Generation method depends on value of /lambda/:

  - 0</lambda/<=30: count number of events /lambda>30/:
  - Acceptance-Rejection due to Atkinson (see Banks, page 166)


-----

# link target 2: <<probability-density-function>>
# link target: <<function probability-density-function>>


**** External Function: =probability-density-function=                     :function:


***** Syntax

#+BEGIN_SRC lisp
(probability-density-function instance x)
#+END_SRC


***** Description

Returns the estimated value of the Probability
  Density Function at a given x.



-----

# link target 2: <<process-message>>
# link target: <<function process-message>>


**** External Function: =process-message=                                  :function:


***** Syntax

#+BEGIN_SRC lisp
(process-message channel message time)
#+END_SRC

***** Arguments

- channel :: an instance of [[class channel]]
- message :: the [[class message]] to be processed
- time :: [[time-type]] the time message is to be processed

***** Returns

- channel-result :: a [[structure channel-result]]

***** Description


This method encapsulates the channel's functionality. The method
should model the transmission of the given message starting at the
given time, and return the propagation delay, transmission
duration, and discard flag in the channel-result object.

Transmission duration and bit error modeling only applies to packets
i.e. to instances of [[class packet]], it should be skipped for
non-packet messages. The method does not need to set the [[duration]]
of the packet; this is done by the simulation kernel. However, the
method should call [[function (setf bit-error)]] on the packet if
error modeling results in bit errors.

If the method sets the discard flag in the result object, it means
that the message object should be deleted by the simulation kernel;
this facility can be used to model that the message gets lost in the
channel.

The method does not need to throw errors on overlapping transmissions,
or if the packet's duration field is already set; these checks are
done before [[process-message]] is called.

***** Simulation Events


- message-discarded :: [[structure timestamped]] with message
  as value should be emited if the [[class message]] is being discarded

- message-sent :: [[structure message-sent-signal-value]] should
  be emitted if message is successfully delivered with both the
  [[class message]] and [[structure channel-result]] objects.

***** See also

[[structure channel-result]]



-----

# link target 2: <<property-union>>
# link target: <<function property-union>>


**** External Function: =property-union=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(property-union list1 list2)
#+END_SRC

***** Arguments

- list1 :: a property list
- list2 :: a property list

***** Returns

- list :: a property list

***** Description


This is intended to implement property inheritence.

Returns a merged property list combining properties from list1 and
list2. list1 property will have priority except if the property
values are themselves a list in which case the result is list2 value
appended onto end of list1 value.


-----

# link target 2: <<queue>>
# link target: <<function queue>>


**** External Function: =queue=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(queue object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<rand>>
# link target: <<function rand>>


**** External Function: =rand=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(rand stream &optional limit)
#+END_SRC

***** Arguments


- stream :: a random number sequence stream

***** Optional Arguments


- limit :: a +real+ (default 1.0)

***** Description


Return a random number /x/ of same type as /limit/ from a random
number sequence stream in the range 0<= /x/ <= /limit/ . See also
[[randexc][randExc]]


-----

# link target 2: <<range-getf>>
# link target: <<function range-getf>>


**** External Function: =range-getf=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(range-getf spec index)
#+END_SRC

***** Arguments

- spec :: a range property list
- index :: a number

***** Results

- result :: a value corresponding to =index= in =spec= or =nil= if no match
- index :: the lower index of range corresponding to match

***** Description


Range property lists are plists where the property indicator is
either a number indicating a single value or a cons of a lower and
upper range.

[[range-getf]] finds the property in =spec= that either === the =index= or where=index= lies between the upper and lower bound of the specified range.

Property ranges are typically used to specify parameters that vary depending on an index.

***** Examples


#+BEGIN_SRC lisp
 (range-getf '(1  A (2 6) B 7 C (8 10) D) 1)
 => A,1
 (range-getf '(1  A (2 6) B 7 C (8 10) D) 5)
 => B,2
 (range-getf '(1  A (2 6) B 7 C (8 10) D) 0)
 =>nil,0
#+END_SRC


-----

# link target 2: <<range-list-p>>
# link target: <<function range-list-p>>


**** External Function: =range-list-p=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(range-list-p spec)
#+END_SRC


***** Description

Return true if =spec= is a valid range property list.

***** See Also

[[range-getf]]



-----

# link target 2: <<read-configuration>>
# link target: <<function read-configuration>>


**** External Function: =read-configuration=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(read-configuration pathname &optional (key general))
#+END_SRC

***** Arguments

- pathname :: a path designator for a a configuration file
- key :: string or list of strings designating sections (default "General")

***** Returns

- trie :: A trie containing configuration

***** Description


This functions reads the configuration keys from a source file
designated by =pathname= one or more sections designated by =key= and
returns a trie containing the fully resolved
configuration. Configuration files are used to specify the parameters
for the simulation and the heirachy of components therein.

If a list of sections is given in =key= they are read in the specified order.
If the "General" section is not listed it will be read at the end.

***** Configuration File Format


The configuration data have the following syntax.

- comments :: #<comment>
- section :: [<section-title>]
- file-inclusion :: include <path>
- parameter-definition :: <parameter-name> = <parameter-value>
- parameter-name :: (<name-part>.*)<name-part>
- name-part :: <name>|<glob>|<index>
- glob :: <*>|<**>
- index :: <integer> | <range>
- name :: <character>+
- range :: <integer>-<integer>

Configuration data is read line per line. Everything after # on a line
is considered a comment. If a line ends with a #\ it is assumed the
following line is a continuation line. All parameters are read into
named sections designated by the previous <section> or "General"
section if no previous section title is given.

<file-inclusion> is used to insert the contents of another file at the
given point. It is exactly as if the lines from that file where
inserted at that point.

The <parameter-name> is used to specify which durind simulation
Parameters for the simulation have heirarchical names which correspond
to the heirarchy of named components in the simulation. Globs may be
used to specify an any match. * corresponds to matching a single
paramater-name whereas ** will match a sequence of names in the
heirarchy. For indexed components the index may either be a single
integer or a range of values seperated with -.

****** Examples


See ini files included with source code.



-----

# link target 2: <<read-parameter>>
# link target: <<function read-parameter>>


**** External Function: =read-parameter=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(read-parameter full-path source format)
#+END_SRC


***** Description

Loopup a fully named parameter from a configuration
  trie and convert from string to internal representation using
  [[parse-input]] with the specified format. If the format is a
  pathname it may be relative to the path of the source file from
  which the parameter was read.



-----

# link target 2: <<receive-signal>>
# link target: <<function receive-signal>>


**** External Function: =receive-signal=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(receive-signal listener signal source value)
#+END_SRC

***** Arguments


- listener :: an [[entity-with-signals]] instance.
- signal :: a signal designator (=symbol= or =integer=)
- source :: an [[entity-with-signals]] instance.
- value :: signalled value

***** Description


A call of [[emit]] with signal value /signal/ from
[entity-with-signals]] object/source/ and value /value/ will result in
[[receive-signal]] being called in the /source/ object and all ancestor
objects in the simulation heirarchy that have registered to receive
this /signal/ using [[subscribe]]

All objects which wish to receive signals must specialise this method.


-----

# link target 2: <<record>>
# link target: <<function record>>


**** External Function: =record=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(record recorder time value)
#+END_SRC

***** Arguments


- recorder :: a [[result-recorder]]
- time :: a [[time-type]]
- value :: a =number=

***** Description


Must be specialised for all [[result-recorder]] classes to record the
/value/ at simulation time /time/. /value/ will usually be a number
but could be a structure containing more information or treated as a
boolean for simple counting recorders.


-----

# link target 2: <<register-signal>>
# link target: <<function register-signal>>


**** External Function: =register-signal=                                  :function:


***** Syntax

#+BEGIN_SRC lisp
(register-signal symbol &optional documentation)
#+END_SRC


***** Description

*Arguments
- symbol :: a =symbol=

***** Optional Arguments


- documentation :: a =string=

***** Returns


- signal-id :: an =integer=

***** Description


Register signal denoted by /symbol/ and optionally recording the
/documentation/. If the named signal has not previously been
registered it will be allocated a new integer /signal-id/ stored in
the =signal-id= property of the symbol and it will be added onto the
end of the global [[*signals*]] array. /documentation/ is stored in
the =signal-doc= symbol.

[[register-signal]] is intended to be called as a top level form.

The first [[..2b..signal-cache-size..2b..][+signal-cache-size+]] signals registered are cached by
[[entity-with-signals]] objects and therefore the signals which are
most heavily used should be registered first when loading the
simulation code.



-----

# link target 2: <<reinitialise-slots>>
# link target: <<function reinitialise-slots>>


**** External Function: =reinitialise-slots=                               :function:


***** Syntax

#+BEGIN_SRC lisp
(reinitialise-slots slot-names instance)
#+END_SRC

***** Arguments

- slots-names :: a list of slot names
- source :: a class instance

***** Description


Reset the names slots in instance to their initial values as defined
in the slot definitions for the instance class


-----

# link target 2: <<repair-signal-flags>>
# link target: <<function repair-signal-flags>>


**** External Function: =repair-signal-flags=                              :function:


***** Syntax

#+BEGIN_SRC lisp
(repair-signal-flags component)
#+END_SRC

***** Arguments


- component :: an [[entity-with-signals]]

***** Description


Adjusts has-ancestor-listeners bits in the component's subtree; It
must be called when the component's ownership changes.


-----

# link target 2: <<report>>
# link target: <<function report>>


**** External Function: =report=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(report recorder stream)
#+END_SRC

***** Arguments


- recorder :: a [[result-recorder]]
- stream :: a /stream-designator/

***** Description


Must be specialised for all [[result-recorder]] classes to report the
statistic value to /stream/. Defined for the [[scalar-recorder]] class
to output the value returned from [[recorded-value]] using the
[[output-format]] format string and for [[vector-recorder]] to output
the vector returned from [[recorded-vector]] at full precision.

***** Notes


The [[finish]] method will be called on the [[result-recorder]] in
order for it to complete its statistics analysis at the simulation
termination time beforer any calls to [[report]]


-----

# link target 2: <<rng-map>>
# link target: <<function rng-map>>


**** External Function: =rng-map=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(rng-map context)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<root-event>>
# link target: <<function root-event>>


**** External Function: =root-event=                                       :function:


***** Syntax

#+BEGIN_SRC lisp
(root-event object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<run-simulations>>
# link target: <<function run-simulations>>


**** External Function: =run-simulations=                                  :function:


***** Syntax

#+BEGIN_SRC lisp
(run-simulations pathname &key (config general) (repeat 1) runnumber preview)
#+END_SRC

***** Arguments


- pathname :: a path designator

***** Keyword Arguments


- config :: a =string= or list of strings (default "General")
- repeat :: an =integer= >= 1 (default 1)
- runnumber :: an =integer= >= 1
- preview :: a =boolean=

***** Description


Executes one or more simulations using the configuration file at
/pathname/. /config/ lists one or more sections of the configuration
file to use for this run. They will be loaded in order and the
"General" section will always be read last. /repeat/ specifies how
many times to run the simulation. Each run will be with different seed
parameters of the random number generators. If /runnumber/ is
specified then it specifies a single run within a sequence if the
configuration file specifies iteration over some parameters.  If
/preview/ is true simulations are not run but onfiguration parameters
for each run are printed out.


-----

# link target 2: <<schedule>>
# link target: <<function schedule>>


**** External Function: =schedule=                                         :function:


***** Syntax

#+BEGIN_SRC lisp
(schedule event &key delay time)
#+END_SRC

***** Arguments


- event :: and [[event]]

***** Keyword Arguments


- delay :: a positive =real=
- time :: a positive =real=

***** Description


Schedule event to be handled at the given simulation time /time/ or
/delay/ after current simulation time. If no /delay/ or /time/ is
provided the [[arrival-time]] value of the event is used. The
scheduled time must be >= current simulation-time i.e. in the
future.


-----

# link target 2: <<schedule-at>>
# link target: <<function schedule-at>>


**** External Function: =schedule-at=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(schedule-at module message &key time delay)
#+END_SRC

***** Arguments


- module :: a [[module]]
- message :: a [[message]]

***** Keyword Arguments

- time :: a [[time-type]]
- delay :: a [[time-type]]

***** Description


Schedule a self-message. The /message/ will be delivered back to
/module/ via [[handle-message]] either at absolute simulation time
/time/ or after delay /delay/ which will be added onto the current
simulation time. This function is the way you can implement timers or
timeouts. Timers can also be cancelled via [[cancel]].
When the message is delivered at the module, you can call
[[self-message]] to tell it apart from messages arriving
from other modules.

[[cancel]] can be used to cancel the self-message before it arrives.
This is useful for implementing timeouts: if the event occurs 'in time'
 (before timeout), the scheduled self-message can be cancelled.

Given a message you can check whether it is currently
scheduled by calling [[scheduled-p]]. If it is scheduled,
you cannot schedule it again without calling [[cancel]] first.
However, after the message was delivered to the module or cancelled,
you can schedule it again -- so you can reuse the same message
object for timeouts over and over during the whole simulation.

 * Notes

The preferred way of implementing timers is now provided using
[[timer-message]]s, [[set-timer]] and [[cancel-timer]].



-----

# link target 2: <<scheduled-p>>
# link target: <<function scheduled-p>>


**** External Function: =scheduled-p=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(scheduled-p event)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<sec>>
# link target: <<function sec>>


**** External Function: =sec=                                              :function:


***** Syntax

#+BEGIN_SRC lisp
(sec stream arg &optional colon-p at-p (d 3) (padchar  ) (exponentchar e))
#+END_SRC

***** Arguments

- stream :: An output stream designator.
- arg :: time format argument
- colon-p :: ignored
- at-p :: ignored
- D :: number of digits to print after decimal point
- padchar :: character to print leading the output
- exponentchar :: character to print before exponent.

***** Description


Simulation Time formatter function outputs a time argument =arg= to =stream=
in engineering format.

***** Example

#+BEGIN_SRC lisp
 (format nil "~3/lens:sec/" 0.5689)
 => "568.900ms"
#+END_SRC

***** See also

- [[dfv:eng]]


-----

# link target 2: <<seed>>
# link target: <<function seed>>


**** External Function: =seed=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(seed stream seed)
#+END_SRC

***** Arguments


- stream :: a random number sequence stream
- seed :: a 32 bit =integer= or =t=

Reseed /stream/ using /seed/. A seed value of =t= will use the system
random source to seed


-----

# link target 2: <<self-message-p>>
# link target: <<function self-message-p>>


**** External Function: =self-message-p=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(self-message-p message)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<send>>
# link target: <<function send>>


**** External Function: =send=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(send module message gateid &key delay)
#+END_SRC

***** Arguments


- module :: a [[module]]
- message :: a [[message]]
- gateid :: a gate descriptor (a [[gate]] or list of gate name, direction and index.
- delay :: a [[time-type]]

***** Description


Schedule sending /message/ through the specified /gate/ of given
/module/ after given /delay/. The /delay/ is added onto the current
[[simulation-time]] to determine delivery time and the source gate of
the message will be sent. [[deliver]] is called to actually schedule
the /message/. 


-----

# link target 2: <<send-direct>>
# link target: <<function send-direct>>


**** External Function: =send-direct=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(send-direct module togate message &key propagation-delay duration)
#+END_SRC

***** Arguments


- module :: a [[module]]
- togate :: a  [[gate]]
- message :: a [[message]]

***** Keyword Arguments


- propagation-delay :: a [[time-type]]
- duration :: a [[time-type]]

***** Description


Send /message/ directly to the /togate/ gate of another module.

If the target /togate/ is further connected
the message will follow the connections that start at that gate.  For
example, when sending to an input gate of a [[compound-module]], the
message will follow the connections inside the compound module.

It is permitted to send to an output gate, which will also cause the
message to follow the connections starting at that gate.  This can be
useful, for example, when several submodules are sending to a single
output gate of their parent module.

It is not noramlly permitted to send to a gate of a [[compound-module]] which is
not further connected unless [[function handle-message]] has been specialised for that [[compound-module]] class.

Also, it is not permitted to send to a gate which is otherwise
connected i.e. which has a [[previous-gate]]. This means that modules
*must* have dedicated gates for receiving via [[send-direct]]. You cannot
have a gate which receives messages via both connections and
[[send-direct]].

When a nonzero /duration/ is given, that signifies the duration of the
packet transmission, that is, the time difference between the
transmission (or reception) of the start of the packet and that of the
end of the packet. The destination module can choose whether it wants
the simulation kernel to deliver the packet object to it at the start
or at the end of the reception. The default is the latter; the module
can change it by calling [[deliver-on-reception-start]] on the final
input gate (that is the [[path-end-gate]]). [[deliver-on-reception-start]]
needs to be called in advance, for example in the [[initialize]] method of
the module. When a module receives a packet, it can call the
[[reception-start-p]] and [duration]] methods on the packet to find out
whether it represents the start or the end of the reception, and the duration of
the transmission.

For messages that are not packets the /duration/ must be zero.


-----

# link target 2: <<sent-time>>
# link target: <<function sent-time>>


**** External Function: =sent-time=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(sent-time object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<serialise>>
# link target: <<function serialise>>


**** External Function: =serialise=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(serialise o stream)
#+END_SRC


***** Description

Serialise an object into a stream. Fur future use.



-----

# link target 2: <<set-slots>>
# link target: <<function set-slots>>


**** External Function: =set-slots=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(set-slots instance defs)
#+END_SRC

***** Arguments

- instance :: a class instance
- defs :: a list of lists

***** Description


Used to set multiple slot values in a class instance. defs is a list
of slot setting options. The first element of each option is the
slot name and the second element is the value to set the slot to.


-----

# link target 2: <<set-timer>>
# link target: <<function set-timer>>


**** External Function: =set-timer=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(set-timer module timer interval &optional timer-name)
#+END_SRC

***** Arguments


- module :: an instance of [[with-timers]]
- timer :: a timer designator (either =symbol= or [[timer-message]])
- interval :: a [time-type]]

***** Optional Arguments

- timer-name :: a =symbol=

***** Description


Schedule a timer designated by /timer/ to be fired after simulation
interval /interval/. [[handle-message]] will be called after
/interval/ with the /module/ and /timer-name/ as its arguments. If
/timer/ is a [[timer-message]] it will be givne the name /timer-name/.

If a timer designated by /timer/ already exists it will be cancelled
and rescheduled otherwise a new [[timer-message]] will be created with
the given name and added onto the =timers= slot list of /module/.

For efficiency if classes have a slot with slot-name /timer-name/ it
is assumed that this will contain the [[timer-message]] to be used. In
this case the slot definition should definine (make-instance
'timer-message) as the initform.


-----

# link target 2: <<signal-id>>
# link target: <<function signal-id>>


**** External Function: =signal-id=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(signal-id symbol)
#+END_SRC


***** Description

Return the integer id of the named signal.



-----

# link target 2: <<sim-time-limit>>
# link target: <<function sim-time-limit>>


**** External Function: =sim-time-limit=                                   :function:


***** Syntax

#+BEGIN_SRC lisp
(sim-time-limit object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<simulation-time>>
# link target: <<function simulation-time>>


**** External Function: =simulation-time=                                  :function:


***** Syntax

#+BEGIN_SRC lisp
(simulation-time &optional (simulation *simulation*))
#+END_SRC


***** Description

Return the simulation time of the current running simulation.



-----

# link target 2: <<size>>
# link target: <<function size>>


**** External Function: =size=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(size s)
#+END_SRC


***** Description

Return the number of elements stored in a data structure



-----

# link target 2: <<stop>>
# link target: <<function stop>>


**** External Function: =stop=                                             :function:


***** Syntax

#+BEGIN_SRC lisp
(stop simulation &key abort)
#+END_SRC

***** Arguments


- simulation :: a [[simulation]] object

***** Keyword Arguments


- abort :: a =boolean=

***** Description


Stop the /simulation/. If /abort/ is teu this will stop immediately by killing the thread in which the simulation is running otherwise it will stop after it has finished processing the current [[even]].


-----

# link target 2: <<student-t>>
# link target: <<function student-t>>


**** External Function: =student-t=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(student-t i &optional (rng 0))
#+END_SRC

***** Arguments


- i :: a positive integer

***** Optional Arguments


- rng :: an =integer= (default 0)

Returns a random variate from the student-t distribution with /i/
degrees of freedom  using the random number stream /rng/ in the current
context.

If Y1 has a normal distribution and Y2 has a
chi-square distribution with k degrees of freedom then X = Y1 /
sqrt(Y2/k) has a student-t distribution with k degrees of freedom.

Generation is using relationship to gamma and [[chi-square]].


-----

# link target 2: <<submodule>>
# link target: <<function submodule>>


**** External Function: =submodule=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(submodule module address &key index)
#+END_SRC

***** Arguments


- module :: a [[module]]

- address :: a /submodule-specifier/

   * /submodule-specifier/ : ( (/submodule-name/ | ( /submodule-name/ index))*)

   * /submodule-name/ : a =symbol=

   * /index/ L an =integer=

***** Description


Return the submodule of a module given a heirarchical address. This
will recurse throguh the submodule structure in order if the address
is a list of submodules names. At each stage the submodule name or the
name and index are used to recurse further down. It will return an
error if there is no such named submodule.


-----

# link target 2: <<subscribe>>
# link target: <<function subscribe>>


**** External Function: =subscribe=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(subscribe entity signal listener)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: =symbol= signal identifier
- listener :: an object

***** Description


Adds a listener (callback object) that will be notified using the
[[receive signal]] method when the given signal is emitted (see
[[emit]] methods). It is an error to subscribe the same listener twice
to the same signal. The order in which listeners will be notified is
undefined.


-----

# link target 2: <<subscribed-p>>
# link target: <<function subscribed-p>>


**** External Function: =subscribed-p=                                     :function:


***** Syntax

#+BEGIN_SRC lisp
(subscribed-p entity signal listener)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: =symbol= signal identifier
- listener :: an object

***** Description


Removes the given /listener/ from the subscription list for signal
designated by /signal-id/ in /entity/ . It has no effect if the
given listener was not subscribed using [[subscribe]].

Returns true if the given /listener/ is subscribed to the signal
designated by /signal-id/ at /entity/ component (i.e. it does not look
at listeners subscribed at ancestor components).


-----

# link target 2: <<timer>>
# link target: <<function timer>>


**** External Function: =timer=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(timer module name)
#+END_SRC

***** Arguments


- module :: an instance of [[with-timers]]
- name :: a =symbol=

***** Description


Return the timer message with name /name/ associated with
/module/. If the /module/ has a slot with slot-name /name/ then
the slot value will be returned - otherwise the /timers/ slot of the
component will be search for the named timer.


-----

# link target 2: <<timestamp>>
# link target: <<function timestamp>>


**** External Function: =timestamp=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(timestamp object)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<timestamped-time>>
# link target: <<function timestamped-time>>


**** External Function: =timestamped-time=                                 :function:


***** Syntax

#+BEGIN_SRC lisp
(timestamped-time instance)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<timestamped-value>>
# link target: <<function timestamped-value>>


**** External Function: =timestamped-value=                                :function:


***** Syntax

#+BEGIN_SRC lisp
(timestamped-value instance)
#+END_SRC


***** Description

Return whether debug-block represents elsewhere code.



-----

# link target 2: <<title>>
# link target: <<function title>>


**** External Function: =title=                                            :function:


***** Syntax

#+BEGIN_SRC lisp
(title instance)
#+END_SRC

***** Arguments


- instance :: a [[statistic-listener]]

***** Description


Return the publishable title for a result from a [[statistic-listener]]. Declared in the arguments to the =:statistic= property of a [[component]].


-----

# link target 2: <<to-gate>>
# link target: <<function to-gate>>


**** External Function: =to-gate=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(to-gate message)
#+END_SRC


***** Description

Not documented.



-----

# link target 2: <<to-module>>
# link target: <<function to-module>>


**** External Function: =to-module=                                        :function:


***** Syntax

#+BEGIN_SRC lisp
(to-module message)
#+END_SRC


***** Description

Not documented.



-----

# link target: <<function transmission-channel>>


**** External Function: =transmission-channel=                             :function:


***** Syntax

#+BEGIN_SRC lisp
(transmission-channel gate &optional incoming-p)
#+END_SRC


***** Description

Typically invoked on an output gate, this method
  returns the channel in the connection path that supports
  datarate (as determined; it is guaranteed that there can be at most
  one such channel per path). If there is no such channel, nil is
  returned. If incoming-p is true looks for an incoming channel - else
  returns the outgoing channel.



-----

# link target 2: <<transmission-finish-time>>
# link target: <<function transmission-finish-time>>


**** External Function: =transmission-finish-time=                         :function:


***** Syntax

#+BEGIN_SRC lisp
(transmission-finish-time channel)
#+END_SRC

***** Arguments

- channel :: a [[transmission-channel]]

***** Returns

- duration :: a [[time-type]]

***** Description


Returns the simulation time the sender gate will finish transmitting
over a transmission channel. If the gate is not currently
transmitting, the result is unspecified but less or equal the current
simulation time.


-----

# link target 2: <<triang>>
# link target: <<function triang>>


**** External Function: =triang=                                           :function:


***** Syntax

#+BEGIN_SRC lisp
(triang a b c &optional (rng 0))
#+END_SRC

***** Arguments


- a :: a /real/
- b :: a /real/
- c :: a /real/

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the triangular distribution with parameters
/a/ <= /b/ <= /c/.

Generation uses inverse transform.


-----

# link target 2: <<truncnormal>>
# link target: <<function truncnormal>>


**** External Function: =truncnormal=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(truncnormal &optional (m 0.0d0) (d 1.0d0) (rng 0))
#+END_SRC

***** Optional Arguments


- m :: a =real= number (default 0d0)
- d ::  a =real= number (default 1d0)
- rng :: an =integer= (default 0)

***** Description


Return the Normal distribution (from [[normal]] truncated to
nonnegative values from the random number stream /rng/ in the current
context.

It is implemented with a loop that discards negative values until a
nonnegative one comes. This means that the execution time is not
bounded: a large negative mean with much smaller stddev is likely to
result in a large number of iterations.

The mean and stddev parameters /m/ and /d/ serve as parameters to the
normal distribution before truncation. The actual random variate
returned will have a different mean and standard deviation.


-----

# link target 2: <<uniform>>
# link target: <<function uniform>>


**** External Function: =uniform=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(uniform a b &optional (rng 0))
#+END_SRC

***** Arguments


- a :: a =real= number
- b :: a =real= number

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate /x/ =double float= with uniform distribution in the range /a/<=/x/<=/b/ from random number stream /rng/ in the current context.


-----

# link target 2: <<unsubscribe>>
# link target: <<function unsubscribe>>


**** External Function: =unsubscribe=                                      :function:


***** Syntax

#+BEGIN_SRC lisp
(unsubscribe entity signal listener)
#+END_SRC

***** Arguments


- entity :: an [[entity-with-signals]]
- signal-id :: =symbol= signal identifier
- listener :: an object

***** Description


Removes the given /listener/ from the subscription list for signal
designated by /signal-id/ in /entity/ . It has no effect if the
given listener was not subscribed using [[subscribe]].


-----

# link target 2: <<urandom>>
# link target: <<function urandom>>


**** External Function: =urandom=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(urandom size)
#+END_SRC

***** Arguments


- seed :: an =integer=

***** Description


Return an integer /size/ octets long read from the system random stream
/dev/urandom


-----

# link target 2: <<weibull>>
# link target: <<function weibull>>


**** External Function: =weibull=                                          :function:


***** Syntax

#+BEGIN_SRC lisp
(weibull a b &optional (rng 0))
#+END_SRC

***** Arguments


- a :: a /real/ in range /a>0/
- b :: a /real/ in range /b>0/

***** Optional Arguments


- rng :: an =integer= (default 0)

***** Description


Returns a random variate from the Weibull distribution where /a/ is
the 'scale' parameter and /b/ is the shape parameter.  Sometimes
Weibull is given with /alpha/ and /beta/ parameters, then /alpha=b/
and /beta=a/. Uses random number stream /rng/ in the current context.

The Weibull distribution gives the distribution of lifetimes of objects.
It was originally proposed to quantify fatigue data, but it is also used
in reliability analysis of systems involving a weakest link, e.g.
in calculating a device's mean time to failure.

When /b=1/, (weibull a b) is exponential with mean /a/.

Generation uses inverse transform.





** Ambiguous Symbols


*** Gate

# target: <<gate>>
Disambiguation.

- Function: [[function gate][=gate=]]
- Class: [[class gate][=gate=]]



*** Module

# target: <<module>>
Disambiguation.

- Function: [[function module][=module=]]
- Class: [[class module][=module=]]



*** Transmission-Channel

# target: <<transmission-channel>>
Disambiguation.

- Function: [[function transmission-channel][=transmission-channel=]]
- Class: [[class transmission-channel][=transmission-channel=]]



*** Gate-Direction

# target: <<gate-direction>>
Disambiguation.

- Function: [[function gate-direction][=gate-direction=]]
- Type: [[type gate-direction][=gate-direction=]]



*** Network

# target: <<network>>
Disambiguation.

- Variable: [[variable network][=network=]]
- Function: [[function network][=network=]]
- Class: [[class network][=network=]]



*** Channel

# target: <<channel>>
Disambiguation.

- Function: [[function channel][=channel=]]
- Class: [[class channel][=channel=]]



*** Message

# target: <<message>>
Disambiguation.

- Function: [[function message][=message=]]
- Class: [[class message][=message=]]




** Index

 [[index A][A]]  [[index B][B]]  [[index C][C]]  [[index D][D]]  [[index E][E]]
 [[index F][F]]  [[index G][G]]  [[index H][H]]  [[index I][I]]  [[index L][L]]
 [[index M][M]]  [[index N][N]]  [[index O][O]]  [[index P][P]]  [[index Q][Q]]
 [[index R][R]]  [[index S][S]]  [[index T][T]]  [[index U][U]]  [[index W][W]]
 [[index NONALPHABETIC][NONALPHABETIC]]  


*** Nonalphabetic


# link target: <<index NONALPHABETIC>>
- [[variable *context*][=*context*=]], Variable
- [[variable *simulation*][=*simulation*=]], Variable
- [[variable *simulation-init-hooks*][=*simulation-init-hooks*=]], Variable
- [[variable *simulation-trace-stream*][=*simulation-trace-stream*=]], Variable
- [[variable *time-format*][=*time-format*=]], Variable
- [[constant ..2b..c..2b..][=+c+=]], Constant
- [[function ..3c....3d..][=<==]], Function
- [[function ..3c....3d..][=<==]], Function



*** A


# link target: <<index A>>
- [[function arrival-time][=arrival-time=]], Function
- [[function arrived][=arrived=]], Function
- [[function average-queue-time][=average-queue-time=]], Function



*** B


# link target: <<index B>>
- [[function bernoulli][=bernoulli=]], Function
- [[function beta][=beta=]], Function
- [[function binomial][=binomial=]], Function
- [[function bit-error-p][=bit-error-p=]], Function
- [[function bit-length][=bit-length=]], Function
- [[function buffer-size][=buffer-size=]], Function
- [[function buffer-size-bytes][=buffer-size-bytes=]], Function
- [[function build-connections][=build-connections=]], Function
- [[function build-gates][=build-gates=]], Function
- [[function build-inside][=build-inside=]], Function
- [[function build-submodules][=build-submodules=]], Function
- [[function busy-p][=busy-p=]], Function
- [[function byte-length][=byte-length=]], Function



*** C


# link target: <<index C>>
- [[function calculate-duration][=calculate-duration=]], Function
- [[function cancel][=cancel=]], Function
- [[function cancel-timer][=cancel-timer=]], Function
- [[function cauchy][=cauchy=]], Function
- [[function channel][=channel=]], Function
- [[class channel][=channel=]], Class
- [[structure channel-result][=channel-result=]], Structure
- [[function chi-square][=chi-square=]], Function
- [[class component][=component=]], Class
- [[class compound-module][=compound-module=]], Class
- [[class compound-module-class][=compound-module-class=]], Class
- [[function configuration][=configuration=]], Function
- [[function configure][=configure=]], Function
- [[function connect][=connect=]], Function
- [[function connected-outside-p][=connected-outside-p=]], Function
- [[function connected-p][=connected-p=]], Function
- [[function control-info][=control-info=]], Function
- [[structure coord][=coord=]], Structure
- [[function coord*][=coord*=]], Function
- [[function coord..2b..][=coord+=]], Function
- [[function coord-][=coord-=]], Function
- [[function coord-op][=coord-op=]], Function
- [[function coord-x][=coord-x=]], Function
- [[function coord-y][=coord-y=]], Function
- [[function coord-z][=coord-z=]], Function
- [[function copy-slots][=copy-slots=]], Function
- [[function cpu-time-limit][=cpu-time-limit=]], Function
- [[function creation-time][=creation-time=]], Function
- [[function cumulative-density-function][=cumulative-density-function=]],
  Function



*** D


# link target: <<index D>>
- [[function decapsulate][=decapsulate=]], Function
- [[function define-result-recorder][=define-result-recorder=]], Function
- [[macro define-statistic-filter][=define-statistic-filter=]], Macro
- [[function delay][=delay=]], Function
- [[class delay-channel][=delay-channel=]], Class
- [[function deliver][=deliver=]], Function
- [[function deliver-on-reception-start-p][=deliver-on-reception-start-p=]],
  Function
- [[function dequeue][=dequeue=]], Function
- [[function detailed-info][=detailed-info=]], Function
- [[function disabled-p][=disabled-p=]], Function
- [[function disconnect][=disconnect=]], Function
- [[function distance][=distance=]], Function
- [[function do-histogram][=do-histogram=]], Function
- [[function duplicate][=duplicate=]], Function
- [[function duplicate-p][=duplicate-p=]], Function



*** E


# link target: <<index E>>
- [[function emit][=emit=]], Function
- [[function empty-p][=empty-p=]], Function
- [[function encapsulate][=encapsulate=]], Function
- [[function end-module][=end-module=]], Function
- [[function enqueue][=enqueue=]], Function
- [[class entity-with-signals][=entity-with-signals=]], Class
- [[function erlang-k][=erlang-k=]], Function
- [[function exponential][=exponential=]], Function



*** F


# link target: <<index F>>
- [[macro filter][=filter=]], Macro
- [[function find-object][=find-object=]], Function
- [[function finish][=finish=]], Function
- [[macro for][=for=]], Macro
- [[function for-each-channel][=for-each-channel=]], Function
- [[function for-each-child][=for-each-child=]], Function
- [[function for-each-gate][=for-each-gate=]], Function
- [[function for-each-submodule][=for-each-submodule=]], Function
- [[function format-from-type][=format-from-type=]], Function
- [[function from-gate][=from-gate=]], Function
- [[function from-module][=from-module=]], Function
- [[function full-name][=full-name=]], Function
- [[function full-path][=full-path=]], Function



*** G


# link target: <<index G>>
- [[function gamma-d][=gamma-d=]], Function
- [[function gate][=gate=]], Function
- [[class gate][=gate=]], Class
- [[function gate-direction][=gate-direction=]], Function
- [[type gate-direction][=gate-direction=]], Type
- [[function gate-extend][=gate-extend=]], Function
- [[function gate-size][=gate-size=]], Function
- [[class gate-slot][=gate-slot=]], Class
- [[function gate-type][=gate-type=]], Function
- [[function geometric][=geometric=]], Function



*** H


# link target: <<index H>>
- [[function handle-message][=handle-message=]], Function
- [[function handle-timer][=handle-timer=]], Function
- [[function has-listeners][=has-listeners=]], Function
- [[class histogram][=histogram=]], Class
- [[class history-buffer][=history-buffer=]], Class



*** I


# link target: <<index I>>
- [[class ideal-channel][=ideal-channel=]], Class
- [[function index][=index=]], Function
- [[class indexed-count-recorder][=indexed-count-recorder=]], Class
- [[function info][=info=]], Function
- [[function initialize][=initialize=]], Function
- [[function initialized-p][=initialized-p=]], Function
- [[function input][=input=]], Function
- [[function intuniform][=intuniform=]], Function



*** L


# link target: <<index L>>
- [[class last-value][=last-value=]], Class
- [[function latency][=latency=]], Function
- [[function listeners][=listeners=]], Function
- [[function lognormal][=lognormal=]], Function



*** M


# link target: <<index M>>
- [[function make-coord][=make-coord=]], Function
- [[function may-have-listeners][=may-have-listeners=]], Function
- [[class mean][=mean=]], Class
- [[function message][=message=]], Function
- [[class message][=message=]], Class
- [[structure message-sent-signal-value][=message-sent-signal-value=]],
  Structure
- [[function message-sent-signal-value-message][=message-sent-signal-value
  message=]], Function
- [[function message-sent-signal-value-result][=message-sent-signal-value
  result=]], Function
- [[function message-sent-signal-value-timestamp][=message-sent-signal-value
  timestamp=]], Function
- [[function module][=module=]], Function
- [[class module][=module=]], Class
- [[class module-class][=module-class=]], Class
- [[class mt-random-state][=mt-random-state=]], Class



*** N


# link target: <<index N>>
- [[function name][=name=]], Function
- [[class named-object][=named-object=]], Class
- [[function negbinomial][=negbinomial=]], Function
- [[variable network][=network=]], Variable
- [[function network][=network=]], Function
- [[class network][=network=]], Class
- [[function nominal-datarate][=nominal-datarate=]], Function
- [[function normal][=normal=]], Function



*** O


# link target: <<index O>>
- [[function output][=output=]], Function
- [[class owned-object][=owned-object=]], Class
- [[function owner][=owner=]], Function



*** P


# link target: <<index P>>
- [[class packet][=packet=]], Class
- [[class packet-buffer][=packet-buffer=]], Class
- [[class parameter-class][=parameter-class=]], Class
- [[class parameter-object][=parameter-object=]], Class
- [[function parent-module][=parent-module=]], Function
- [[function pareto-shifted][=pareto-shifted=]], Function
- [[function path-end-gate][=path-end-gate=]], Function
- [[function path-start-gate][=path-start-gate=]], Function
- [[function peek][=peek=]], Function
- [[function poisson][=poisson=]], Function
- [[function probability-density-function][=probability-density-function=]],
  Function
- [[function process-message][=process-message=]], Function
- [[function property-union][=property-union=]], Function



*** Q


# link target: <<index Q>>
- [[function queue][=queue=]], Function



*** R


# link target: <<index R>>
- [[function rand][=rand=]], Function
- [[function range-getf][=range-getf=]], Function
- [[function range-list-p][=range-list-p=]], Function
- [[function read-configuration][=read-configuration=]], Function
- [[function read-parameter][=read-parameter=]], Function
- [[function receive-signal][=receive-signal=]], Function
- [[function record][=record=]], Function
- [[function register-signal][=register-signal=]], Function
- [[function reinitialise-slots][=reinitialise-slots=]], Function
- [[function repair-signal-flags][=repair-signal-flags=]], Function
- [[function report][=report=]], Function
- [[function rng-map][=rng-map=]], Function
- [[function root-event][=root-event=]], Function
- [[function run-simulations][=run-simulations=]], Function



*** S


# link target: <<index S>>
- [[function schedule][=schedule=]], Function
- [[function schedule-at][=schedule-at=]], Function
- [[function scheduled-p][=scheduled-p=]], Function
- [[function sec][=sec=]], Function
- [[function seed][=seed=]], Function
- [[function self-message-p][=self-message-p=]], Function
- [[function send][=send=]], Function
- [[function send-direct][=send-direct=]], Function
- [[function sent-time][=sent-time=]], Function
- [[function serialise][=serialise=]], Function
- [[function set-slots][=set-slots=]], Function
- [[function set-timer][=set-timer=]], Function
- [[function signal-id][=signal-id=]], Function
- [[function sim-time-limit][=sim-time-limit=]], Function
- [[class simulation][=simulation=]], Class
- [[class simulation-condition][=simulation-condition=]], Class
- [[function simulation-time][=simulation-time=]], Function
- [[function size][=size=]], Function
- [[class stddev][=stddev=]], Class
- [[function stop][=stop=]], Function
- [[function student-t][=student-t=]], Function
- [[function submodule][=submodule=]], Function
- [[function subscribe][=subscribe=]], Function
- [[function subscribed-p][=subscribed-p=]], Function
- [[class sum][=sum=]], Class



*** T


# link target: <<index T>>
- [[type time-type][=time-type=]], Type
- [[class timeavg][=timeavg=]], Class
- [[function timer][=timer=]], Function
- [[class timer-message][=timer-message=]], Class
- [[function timestamp][=timestamp=]], Function
- [[structure timestamped][=timestamped=]], Structure
- [[structure timestamped-queue][=timestamped-queue=]], Structure
- [[function timestamped-time][=timestamped-time=]], Function
- [[function timestamped-value][=timestamped-value=]], Function
- [[function title][=title=]], Function
- [[function to-gate][=to-gate=]], Function
- [[function to-module][=to-module=]], Function
- [[macro tracelog][=tracelog=]], Macro
- [[function transmission-channel][=transmission-channel=]], Function
- [[class transmission-channel][=transmission-channel=]], Class
- [[function transmission-finish-time][=transmission-finish-time=]], Function
- [[function triang][=triang=]], Function
- [[function truncnormal][=truncnormal=]], Function



*** U


# link target: <<index U>>
- [[function uniform][=uniform=]], Function
- [[class unknown-message][=unknown-message=]], Class
- [[function unsubscribe][=unsubscribe=]], Function
- [[macro until][=until=]], Macro
- [[function urandom][=urandom=]], Function



*** W


# link target: <<index W>>
- [[function weibull][=weibull=]], Function
- [[macro while][=while=]], Macro
- [[class with-timers][=with-timers=]], Class





* Colophon

This documentation was generated from Common Lisp source code using CLOD, version 1.0.
The latest version of CLOD is available [[http://bitbucket.org/eeeickythump/clod/][here]].
